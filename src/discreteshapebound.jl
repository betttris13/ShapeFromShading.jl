"""
```
Z = retrieve_surface(algorithm::DiscreteShapeBound, img::AbstractArray, iterations::Int=2000)
```
Attempts to produce a heightmap from a grayscale image by minimization of a set
of Euler-Lagrange equations. This is done dicretly at each point in the image
utilizing the second derivates of the surface normals their Fourier Transforms.

This algarithm has the same backend as `DiscreteShape` but has its initial
conditions bound.
# Output
Returns an M by N array (matching dimentions of original image) of Float `Z`
that represents the reconstructed height at the point.
# Details
The `albedo` and `illumination_direction` can be manually defined using the
function signiture:
```
Z = retrieve_surface(algorithm::DiscreteShapeBound, img::AbstractArray, albedo::Real, illumination_direction::Vector{T} where T <: Real, iterations::Int=2000)
```
Note: if `albedo` and `illumination_direction` are not defiend they will be
calculated at runtime using `estimate_img_properties`.
# Arguments
The function arguments are described in more detail below.
##  `img`
An `AbstractArray` storing the grayscale value of each pixel within
the range [0,1].
## `albedo`
A `Real` that specifies the albedo (amount of light reflected) of the image. If
`albedo` is specified to must the `illumination_direction`.
## `illumination_direction`
A `Vector{T} where T <: Real` that specifies the tilt value to be used by the
algarithm. The `illumination_direction` should be a vector of the form [x,y,z]
where x,y,z are int he range [0,1]. If `illumination_direction` is specified
to must the `albedo`.
# Example
Compute the heightmap for a synthetic image generated by `generate_surface`.
```julia
using Images, Makie, ShapeFromShading

#generate synthetic image
img = generate_surface(0.5, [0.2,0,0.9], radius = 5)

#calculate the heightmap (using 500 iterations)
Z = retrieve_surface(DiscreteShapeBound(), img, 500)

#normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

#display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:2
surface(r, r, Z)
```
# Reference
1. S. Elhabian, "Hands on Shape from Shading", Computer Vision and Image Processing, 2008.
"""
function retrieve_surface(algorithm::DiscreteShapeBound, img::AbstractArray, iterations::Int=2000)
    ρ,I,σ,τ = estimate_img_properties(img)
    return retrieve_surface(DiscreteShapeBound(), img, ρ, I, iterations)
end

function retrieve_surface(algorithm::DiscreteShapeBound, img::AbstractArray, albedo::Real, illumination_direction::Vector{T} where T <: Real, iterations::Int=2000)
    ρ = albedo
    I = illumination_direction
    E = Array{Float64}(img)
    E = E[1:2:end,1:2:end]
    M,N=size(E)
    p = zeros(axes(E))
    q = zeros(axes(E))
    δp = zeros(axes(E))
    δq = zeros(axes(E))
    R = zeros(axes(E))
    Z = zeros(axes(E))
    for i in CartesianIndices(E)
        if E[i]>0.75
            Z[i]=-100*E[i]
        else
            Z[i]=0
        end
    end
    q,p = imgradients(Z, KernelFactors.sobel, "replicate")
    λ = 1000
    w = centered(0.25*[0 1 0;1 0 1;0 1 0])
    wx,wy = setup_transform_values(M,N)
    return solve_EulerLagrange(ρ,I,iterations,δp,δq,w,p,q,R,λ,wx,wy,E,Z)
end
