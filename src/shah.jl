"""
```
Z = retrieve_surface(algorithm::Shah, img::AbstractArray, iterations::Int=200)
```
Attempts to produce a heeghtmap from a grayscale image using Shah's algorithm.

Under the assumption that the albedo is constant and the surface is Lambertian,
the algarithm employs discrete approximations of p and q using finite
differences in order to linearize the reflectance map in terms of Z by taking
the first term of its Taylor series expansion.
# Output
Returns an M by N array (matching dimentions of original image) of Float `Z`
that represents the reconstructed height at the point.
# Details
The `slant` and `tilt` can be manually defined using the function signiture:
```
Z = retrieve_surface(algorithm::Shah, img::AbstractArray, slant::Real, tilt::Real, iterations::Int=200)
```
# Arguments
The function arguments are described in more detail below.
##  `img`
An `AbstractArray` storing the grayscale value of each pixel within
the range [0,1].
## `iterations`
An `Int` that specifies the number of iterations the algarithm is to perform. If
left unspecified a default value of 200 is used.
## `slant`
A `Real` that specifies the slant value to be used by the algarithm. The `slant`
should be a value in the range [0,π/2]. If `slant` is specified to must the `tilt`.
## `tilt`
A `Real` that specifies the tilt value to be used by the algarithm. The `tilt`
should be a value in the range [0,2π]. If `tilt` is specified to must
the `slant`.
# Example
Compute the heightmap for a synthetic image generated by `generate_surface`.
```julia
using Images, Makie, ShapeFromShading

#generate synthetic image
img = generate_surface(0.5, [0.2,0,0.9], radius = 5)

#calculate the heightmap
Z = retrieve_surface(Shah(), img)

#normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

#display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:2
surface(r, r, Z)
```
# Reference
1. T. Ping-Sing and M. Shah, "Shape from shading using linear approximation", Image and Vision Computing, vol. 12, no. 8, pp. 487-498, 1994. [doi:10.1016/0262-8856(94)90002-7](https://doi.org/10.1016/0262-8856(94)90002-7)
"""
function retrieve_surface(algorithm::Shah, img::AbstractArray, iterations::Int=200)
    ρ,I,σ,τ = estimate_img_properties(img)
    return retrieve_surface(Shah(), img, σ, τ, iterations)
end

function retrieve_surface(algorithm::Shah, img::AbstractArray, slant::Real, tilt::Real, iterations::Int=200)
    σ, τ = slant,tilt
    E = Float64.(img)
    E = E .* 255
    M, N = size(E)
    p = zeros(axes(E))
    q = zeros(axes(E))
    Z = zeros(axes(E))
    Zx = zeros(axes(E))
    Zy = zeros(axes(E))
    ix = cos(τ) * tan(σ)
    iy = sin(τ) * tan(σ)
    R = zeros(axes(E))
    @inbounds for i = 1:iterations
        #calculate reflectance map
        R = (cos(σ) .+ p .* cos(τ) * sin(σ) .+ q .* sin(τ) * sin(σ)) ./ sqrt.(1 .+ p.^2 + q.^2) #18 aloc
        R = max.(0, R)
        f = E .- R
        #calculate derivative of f in respect to Z
        δf_δZ = (p + q) .* (ix .* p + iy .* q .+ 1) ./
            (sqrt.((1 .+ p.^2 + q.^2).^3) * sqrt(1 + ix^2 + iy^2)) -
            (ix + iy) ./ (sqrt.(1 .+ p.^2 + q.^2) * sqrt(1 + ix^2 + iy^2)) #39 aloc

        #update surface and its normals
        Z = Z - f ./ (δf_δZ .+ eps())
        Zx[2:M,:] = Z[1:M-1,:]
        Zy[:,2:N] = Z[:,1:N-1]
        p = Z - Zx
        q = Z - Zy
    end

    Z = mapwindow(median!, abs.(Z), (21,21))
    return Z
end
