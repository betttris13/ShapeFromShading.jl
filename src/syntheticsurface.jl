@doc raw"""
```
img = generate_surface(albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; radius::Real = 50, scale_factor::Real = 1.5, resolution::Real = 0.1)
```
Creates a synthetic image of a sphere with the given illumination properties.
# Output
Returns a grayscale image with dimensions ``2\times\text{radius}\times\text{scale}
\times\dfrac{1}{\text{resolution}}`` in both axes.
# Details
Uses the passed properties to calculate the partial differentials of the sphere
reflectance and uses these to generate a synthetic image of the sphere to be used
as a consistent test image for SFS testing.
# Arguments
The function arguments are described in more detail below.
## `albedo`
A `Real` that specifies the albedo (amount of light reflected) of the image. If
left unspecified a default value of 0.5 is used.
## `illumination_direction`
A `Vector{T} where T <: Real` that specifies the tilt value to be used by the
algorithm. The `illumination_direction` should be a vector of the form [x,y,z]
where x,y,z are in the range [0,1]. If left unspecified a default value of
[0,0,1] is used.
## `radius`
A `Real` that specifies the radius of the desired sphere. If left unspecified a
default value of 50 is used.
## `scale_factor`
A `Real` that specifies the relative size of the sphere in the image. If
left unspecified a default value of 1.5 is used.
## `resolution`
A `Real` that specifies the how fine the details of the sphere are. If
left unspecified a default value of 0.1 is used. Smaller numbers give higher
quality.
# Example
Compute the heightmap for a synthetic image generated by `generate_surface`.
```julia
using Images, ShapeFromShading

#generate synthetic image
img = generate_surface(0.5, [0.5,0.1,0.7], radius = 25, scale_factor = 1.25, resolution = 0.15)
```
# Reference
1. S. Elhabian, "Hands on Shape from Shading", Computer Vision and Image Processing, 2008.
"""
function generate_surface(albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; radius::Real = 50, scale_factor::Real = 1.5, resolution::Real = 0.1)
    #initialize values
    ρ = albedo
    I = illumination_direction
    r = radius
    xyrange = -scale_factor*r:resolution:scale_factor*r
    range = length(xyrange)

    #setup xyrange
    x = zeros(range , range)
    y = zeros(range , range)
    for i in CartesianIndices(x)
        x[i] = xyrange[i[2]]
        y[i] = xyrange[i[1]]
    end

    R = zeros(Complex{Float64}, axes(x))

    #calculate surface partial differentials
    p = zeros(Complex{Float64}, axes(x))
    q = zeros(Complex{Float64}, axes(x))
    for i in CartesianIndices(x)
        p[i] = x[i] / sqrt(complex(r^2 - (x[i]^2 + y[i]^2)))
        q[i] = y[i] / sqrt(complex(r^2 - (x[i]^2 + y[i]^2)))
    end

    #calculate reflectance
    for i in CartesianIndices(R)
        R[i] = (ρ * (-I[1] * p[i] - I[2] * q[i] + I[3])) / sqrt(complex(1
            + p[i]^2 + q[i]^2))
    end

    #filter
    for i in CartesianIndices(R)
        if r^2 - (x[i]^2 + y[i]^2) <= 0
            R[i] = 0.0
        end
    end

    E = max.(0.0, Float64.(R))

    #convert to img and return
    img = Gray.(E)
    return img
end
