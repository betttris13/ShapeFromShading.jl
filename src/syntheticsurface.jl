"""
```
img = generate_surface(albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; radius::Real = 50, scale_factor::Real = 1.5, resolution::Real = 0.1)
```
produces a sythetic image of a sphere with the given ilumination properties.
# Output
Returns a grayscale image with dimensions 2*radius*scale*resolution in both axes.
# Details
Uses the passed properties to calculate the partial diferentials of the sphere
reflectance and uses these to generate a sythetic image of the sphere.
# Arguments
The function arguments are described in more detail below.
## `albedo`
A `Real` that specifies the albedo (amount of light reflected) of the image. If
left unspecified a default value of 0.5 is used.
## `illumination_direction`
A `Vector{T} where T <: Real` that specifies the tilt value to be used by the
algarithm. The `illumination_direction` should be a vector of the form [x,y,z]
where x,y,z are int he range [0,1]. If left unspecified a default value of
[0,0,1] is used.
## `radius`
A `Real` that specifies the radius of the desired sphere. If left unspecified a
default value of 50 is used.
## `scale_factor`
A `Real` that specifies the relative size of the sphere in the image. If
left unspecified a default value of 1.5 is used.
## `resolution`
A `Real` that specifies the how fine the details of the sphere are. If
left unspecified a default value of 0.1 is used. Smaller numbers give higher
quility.
# Example
Compute the heightmap for a synthetic image generated by `generate_surface`.
```julia
using Images, ShapeFromShading

#generate synthetic image
img = generate_surface(0.5, [0.5,0.1,0.7], radius = 25, scale_factor = 1.25, resolution = 0.15)
```
# Reference
1. S. Elhabian, "Hands on Shape from Shading", Computer Vision and Image Processing, 2008.
"""
function generate_surface(albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; radius::Real = 50, scale_factor::Real = 1.5, resolution::Real = 0.1)
    #initialize values
    ρ = albedo
    I = illumination_direction
    r = radius
    xyrange = -scale_factor*r:resolution:scale_factor*r
    x=zeros(length(xyrange),length(xyrange))
    y=zeros(length(xyrange),length(xyrange))
    for i in CartesianIndices(x)
        x[i]=xyrange[i[2]]
        y[i]=xyrange[i[1]]
    end
    R = zeros(Float64, axes(x))

    #calculate surface partial diferentials
    p = -x./sqrt.(complex(r^2 .-(x.^2+y.^2)))
    q = -y./sqrt.(complex(r^2 .-(x.^2+y.^2)))

    #calculate reflectance
    R = (ρ*(-I[1].*p-I[2].*q.+I[3]))./sqrt.(1 .+ p.^2+q.^2)

    #filter
    mask = ((r^2 .- (x.^2+y.^2) .> 0))
    R = R.*mask
    E = max.(0,Float64.(R))

    #convert to img and return
    img = colorview(Gray, E)
    return img
end
