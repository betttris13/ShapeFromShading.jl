@doc raw"""
```
img = generate_surface(albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; radius::Real = 50, scale_factor::Real = 1.5, resolution::Real = 0.1)
```
Creates a synthetic image of a sphere with the given illumination properties.
# Output
Returns a grayscale image with dimensions ``2\times\text{radius}\times\text{scale}
\times\dfrac{1}{\text{resolution}}`` in both axes.
# Details
Uses the passed properties to calculate the partial differentials of the sphere
reflectance and uses these to generate a synthetic image of the sphere to be used
as a consistent test image for SFS testing.
# Arguments
The function arguments are described in more detail below.
## `albedo`
A `Real` that specifies the albedo (amount of light reflected) of the image. If
left unspecified a default value of 0.5 is used.
## `illumination_direction`
A `Vector{T} where T <: Real` that specifies the tilt value to be used by the
algorithm. The `illumination_direction` should be a vector of the form [x,y,z]
where x,y,z are in the range [0,1]. If left unspecified a default value of
[0,0,1] is used.
## `radius`
A `Real` that specifies the radius of the desired sphere. If left unspecified a
default value of 50 is used.
## `scale_factor`
A `Real` that specifies the relative size of the sphere in the image. If
left unspecified a default value of 1.5 is used.
## `resolution`
A `Real` that specifies the how fine the details of the sphere are. If
left unspecified a default value of 0.1 is used. Smaller numbers give higher
quality.
# Example
Compute the heightmap for a synthetic image generated by `generate_surface`.
```julia
using Images, ShapeFromShading

#generate synthetic image
img = generate_surface(0.5, [0.5,0.1,0.7], radius = 25, scale_factor = 1.25, resolution = 0.15)
```
# Reference
1. S. Elhabian, "Hands on Shape from Shading", Computer Vision and Image Processing, 2008.
"""
function generate_surface(shape::SynthSphere, albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; radius::Real = 50, scale_factor::Real = 1.5, resolution::Real = 0.1)
    # initialize values
    ρ = albedo
    I = normalize(illumination_direction)
    r = radius
    xyrange = -scale_factor*r:resolution:scale_factor*r
    range = length(xyrange)

    #setup xyrange
    x = zeros(range , range)
    y = zeros(range , range)
    for i in CartesianIndices(x)
        x[i] = xyrange[i[2]]
        y[i] = -xyrange[i[1]]
    end

    R = zeros(Complex{Float64}, axes(x))

    #calculate surface partial differentials
    p = zeros(Complex{Float64}, axes(x))
    q = zeros(Complex{Float64}, axes(x))
    for i in CartesianIndices(x)
        p[i] = x[i] / sqrt(complex(r^2 - (x[i]^2 + y[i]^2)))
        q[i] = y[i] / sqrt(complex(r^2 - (x[i]^2 + y[i]^2)))
    end

    #calculate reflectance
    for i in CartesianIndices(R)
        R[i] = (ρ * (-I[1] * p[i] - I[2] * q[i] + I[3])) / sqrt(complex(1
            + p[i]^2 + q[i]^2))
    end

    #filter
    for i in CartesianIndices(R)
        if r^2 - (x[i]^2 + y[i]^2) <= 0
            R[i] = 0.0
        end
    end

    E = max.(0.0, Float64.(R))

    #convert to img and return
    img = Gray.(E)
    return img
end

function generate_surface(shape::Ripple, albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; radius::Real = 1, img_size::Int = 151, resolution::Real = 0.1)
    ρ = albedo
    I = normalize(illumination_direction)
    p = zeros(Float64, img_size, img_size)
    q = zeros(Float64, img_size, img_size)
    for i = 1:img_size
        for j = 1:img_size
            p[i,j] = -((i - img_size / 2) * sin(sqrt((i - img_size / 2)^2 + (j - img_size / 2)^2) / radius)) / (2 * radius * sqrt((i - img_size / 2)^2 + (j - img_size / 2)^2))
            q[i,j] = -((j - img_size / 2) * sin(sqrt((i - img_size / 2)^2 + (j - img_size / 2)^2) / radius)) / (2 * radius * sqrt((i - img_size / 2)^2 + (j - img_size / 2)^2))
            if i - img_size / 2 == 0
                p[i,j] = 0
            end
            if j - img_size / 2 == 0
                q[i,j] = 0
            end
        end
    end
    R = zeros(Float64, img_size, img_size)
    # calculate reflectance
    for i in CartesianIndices(R)
        R[i] = (ρ * (-I[1] * p[i] - I[2] * q[i] + I[3])) / sqrt(1 + p[i]^2 + q[i]^2)
    end

    E = max.(0.0, Float64.(R))

    # convert to img and return
    img = Gray.(E)
    return img
end

function generate_photometric(I₁::Vector{T} where T <: Real = [0, 0, 1], I₂::Vector{T} where T <: Real = [0.5, 0, 1], I₃::Vector{T} where T <: Real = [0, 0.5, 1], albedo::Real=1; shape::SynthShape=SynthSphere())
    img1 = generate_surface(shape, 1, I₁, radius = 5)
    img2 = generate_surface(shape, 1, I₂, radius = 5)
    img3 = generate_surface(shape, 1, I₃, radius = 5)
    return img1, img2, img3
end

function sythetic_gradient(r::Real = 5)
    scale_factor = 1.5
    resolution = 0.1
    xyrange = -scale_factor*r:resolution:scale_factor*r
    range = length(xyrange)

    # setup xyrange
    x = zeros(range , range)
    y = zeros(range , range)
    for i in CartesianIndices(x)
        x[i] = xyrange[i[2]]
        y[i] = -xyrange[i[1]]
    end
    # calculate surface partial differentials
    p = zeros(Complex{Float64}, axes(x))
    q = zeros(Complex{Float64}, axes(x))
    for i in CartesianIndices(x)
        p[i] = x[i] / sqrt(complex(r^2 - (x[i]^2 + y[i]^2)))
        q[i] = y[i] / sqrt(complex(r^2 - (x[i]^2 + y[i]^2)))
        if r^2 <= (x[i]^2 + y[i]^2)
            p[i] = 0
            q[i] = 0
        end
    end
    return Float64.(p), Float64.(q)
end
