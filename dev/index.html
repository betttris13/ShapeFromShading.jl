<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Synthetic-data-generation:-1"><span>Synthetic data generation:</span></a></li><li><a class="tocitem" href="#Normal-Integration:-1"><span>Normal Integration:</span></a></li><li><a class="tocitem" href="#Shape-From-Shading:-1"><span>Shape From Shading:</span></a></li><li><a class="tocitem" href="#Benchmarking:-1"><span>Benchmarking:</span></a></li><li><a class="tocitem" href="#Miscellaneous:-1"><span>Miscellaneous:</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/betttris13/ShapeFromShading.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ShapeFromShading.jl-1"><a class="docs-heading-anchor" href="#ShapeFromShading.jl-1">ShapeFromShading.jl</a><a class="docs-heading-anchor-permalink" href="#ShapeFromShading.jl-1" title="Permalink"></a></h1><p>The following documents the functionality currently available in ShapeFormShading.jl.</p><h2 id="Synthetic-data-generation:-1"><a class="docs-heading-anchor" href="#Synthetic-data-generation:-1">Synthetic data generation:</a><a class="docs-heading-anchor-permalink" href="#Synthetic-data-generation:-1" title="Permalink"></a></h2><h2 id="Normal-Integration:-1"><a class="docs-heading-anchor" href="#Normal-Integration:-1">Normal Integration:</a><a class="docs-heading-anchor-permalink" href="#Normal-Integration:-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Frankot-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Frankot-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Frankot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Frankot()</code></pre><p>Defines the Frankot integrator which contians the Frankot-Chellappa method of integration. The Frankot-Chellappa method is a fast, reliable method for integration surface normals while enforcing integrability using Fourier methods.</p><p><strong>Output</strong></p><p><code>Frankot()</code> returns a Frankot integrator which can then be called to run the Frankot-Chellappa method on a gradient field.</p><p><strong>Details</strong></p><p>Frankot-Chellappa method uses Fourier methods to attempt to solve the Poission equation <span>$\nabla^2z = \partial_up + \partial_vq$</span>. By taking the Fourier transform of both sides we get:</p><div>\[−(\omega^2_u + \omega^2_v)\hat{z}(\omega_u, \omega_v) = \imath \omega_u\hat{p}
(\omega_u, \omega_v) + \imath \omega_v\hat{q}(\omega_u, \omega_v)\]</div><p>By rearranging the above equation we arrive at an equation for <span>$\hat{z}$</span>;</p><div>\[\hat{z}(\omega_u, \omega_v) = \frac{\omega_u\hat{p}(\omega_u, \omega_v) +
\omega_v\hat{q}(\omega_u, \omega_v)}{\imath(\omega^2_u + \omega^2_v)}\]</div><p>From which the final surface can be found by taking the inverse Fourier transform of <span>$\hat{z}$</span>.</p><p>Due to the way <span>$(\omega_u, \omega_v)$</span> is defined the algorithm works best when the input dimensions are odd in length. To accommodate this the integrator will pad the edge of the inputs if they are even before running the algorithm. This padding will be removed before returning a value hence output size will be unaffected.</p><p><strong>Parameters</strong></p><p><code>Frankot</code> integrator take no parameters.</p><p><strong>Example</strong></p><p>The following example demonstrates  the use of the <code>Frankot</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Frankot() integrator
frankot = Frankot()

# Calculate the heightmap from the gradients
Z = frankot(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>[1] R. T. Frankot and R. Chellappa, &quot;A method for enforcing integrability in shape from shading algorithms,&quot; in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 10, no. 4, pp. 439-451, July 1988. <a href="https://doi.org/10.1109/34.3909 ">doi: 10.1109/34.3909</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Path-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Path-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Path()</code></pre><p>Creates a <code>Path()</code> integrator which utilises the average of two path integrals along varying paths. Each path integral reconstructs the surface with accumulating error along the path, hence averaging two different paths can minimise this error, although the method still suffers if the gradient field is not integrable at some points.</p><p><strong>Output</strong></p><p><code>Path()</code> returns a Path integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>Under the assumption that the surface normals are approximately integrable everywhere (<span>$\frac{\partial p}{\partial y}\approx\frac{\partial q}{\partial x}$</span>), then surface can be reconstructed using the path integral defined as:</p><div>\[z(x,y)=\oint_c\left(\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}\right)\cdot dl\]</div><p>Which can be broken into two integrals representing the value at each point on the surface as shown below for a path which integrates along the first column then along the row.</p><div>\[z(u,v)=\int_0^v\frac{\partial z}{\partial y}(0,y)dy + \int_0^u\frac{\partial z}{\partial x}(x,v)dx\]</div><p>The second path used in the algorithm is simply the transpose of the first, integrating along the first row then down the column represented mathematically as:</p><div>\[z(u,v)=\int_0^u\frac{\partial z}{\partial x}(x,0)dx + \int_0^v\frac{\partial z}{\partial y}(u,y)dy\]</div><p>The algorithm can be written, then discretised as shown below:</p><div>\[\begin{gathered}
z(u,v)=\frac{1}{2}\left(\int_0^v\frac{\partial z}{\partial y}(0,y)dy + \int_0^u\frac{\partial z}{\partial x}(x,v)dx + \int_0^u\frac{\partial z}{\partial x}(x,0)dx + \int_0^v\frac{\partial z}{\partial y}(u,y)dy\right)\\
z(u,v)=\frac{1}{2}\left(\sum_{i=0}^vq(0,i) + \sum_{j=0}^up(j,v) + \sum_{j=0}^up(j,0) + \sum_{i=0}^vq(u,i)\right)\\
z(u,v)=\frac{1}{2}\left(\sum_{i=0}^v(q(0,i) + q(u,i)) + \sum_{j=0}^u(p(j,0) + p(j,v))\right)\\
\end{gathered}\]</div><p>It is important to note as mentioned above if there are non-integrable points in the normal field then artefacts can appear in the reconstruction. This is seen in the example below where the otherwise smooth sphere appears &quot;spiky&quot;. This can be corrected post reconstruction by smoothing but ideally a different integrator should be used.</p><p><strong>Parameters</strong></p><p><code>Path</code> integrator take no parameters.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>Path</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Path() integrator
path = Path()

# Calculate the heightmap from the gradients
Z = path(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>[1] D. Forsyth and J. Ponce, Computer vision: a modern approach. Upper Saddle River, N.J: Prentice Hall, 2003, pp. 84-86.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L76-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.SplitPath-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.SplitPath-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.SplitPath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SplitPath()</code></pre><p>Creates a <code>SplitPath()</code> integrator which utilizes the average of two path integrals along varying paths averaging the value at each step. Each path integral reconstructs the surface with accumlating error along the path, hence averaging two different paths at each step reduces the global error at the cost of local error, although the method still suffers if the gradient field is not integrable at some points it does less so the <code>Path()</code> from which it extends.</p><p><strong>Output</strong></p><p><code>SplitPath()</code> returns a SplitPath integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>Under the assumption that the surface normals are approximately integrable everywhere (<span>$\frac{\partial p}{\partial y}\approx\frac{\partial q}{\partial x}$</span>), then surface can be reconstructed using the path integral defined as:</p><div>\[z(x,y)=\oint_c\left(\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}\right)\cdot dl\]</div><p>By expanding on this principle and the discreate summation from <code>Path()</code> we can arrive at the discreate expresion for the value at each point, assuming all values prior to that point have been calculated, as follows:</p><div>\[z_{u,v} = \frac{1}{2}(z_{u-1,v}+p_{u-1,v}+z_{u,v-1}+q_{u,v-1})\]</div><p>As with other similar methods (see <code>Horn()</code>) care must be taken with regards to boundaries which can be calculated, to a constant value <span>$z(0,0)$</span> which is assumed to be the zero point, using:</p><div>\[\begin{gathered}
z_{u,0} = z_{u-1,0}+p_{u-1,0}\\
z_{0,v} = z_{0,v-1}+q_{0,v-1}
\end{gathered}\]</div><p>It is important to note as mentioned above if there are non-integrable points in the normal field then artefacts can appear in the reconstruction. These errors gradually average out but will lead to &quot;streaks&quot; appearing in the reconstruction. This is seen in the example below where the otherwise smooth sphere appears has ripple like structures pointing toward to top right corner. This can be corrected post reconstruction by smoothing but ideally a different integrator should be used. It is also interesting to note the parallels between this method and the Horn and Brooks method, with this method being effectively the forward component of Horn&#39;s method. As such this algorithm provided a useful middle ground between direct integration algorithms and iterative algorithms such as the Horn and Brooks method.</p><p><strong>Parameters</strong></p><p><code>SplitPath</code> integrator take no parameters.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>SplitPath</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Path() integrator
splitPath = SplitPath()

# Calculate the heightmap from the gradients
Z = splitPath(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>[1] D. Forsyth and J. Ponce, Computer vision: a modern approach. Upper Saddle River, N.J: Prentice Hall, 2003, pp. 84-86. [2] B. Horn and M. Brooks, &quot;The variational approach to shape from shading&quot;, Computer Vision, Graphics, and Image Processing, vol. 33, no. 2, pp. 174-208, 1986. <a href="https://doi.org/10.1016/0734-189x(86)90114-3 ">doi: 10.1016/0734-189x(86)90114-3</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L173-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Horn-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Horn-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Horn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Horn(ϵ::Real = 1.0, max_iter::Real = 10000)</code></pre><p>Implements the Horn and Brook&#39;s method of integrating surface normals. This algorithm offers an iterative solution to the Poisson equation describing the surface providing good reconstructions under most conditions.</p><p><strong>Output</strong></p><p><code>Horn()</code> returns a Horn integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>The Horn and Brook&#39;s method attempts to solve the Poisson equation <span>$\nabla^2z = \partial_up + \partial_vq$</span> by the discretization given below:</p><div>\[z_{u+1,v}+z_{u,v+1}+z_{u-1,v}+z_{u,v-1}-4z_{u,v}=\frac{p_{u+1,v}-p_{u-1,v}}{2}+\frac{q_{u,v+1}-q_{u,v-1}}{2}\]</div><p>Which can be rearranged to give the iterative scheme provided by:</p><div>\[z_{u,v}^{k+1}= \frac{z_{u+1,v}^k + z_{u,v+1}^k + z_{u-1,v}^k + z_{u,v-1}^k}{4} - \frac{p_{u+1,v}-p_{u-1,v}}{8} - \frac{q_{u,v+1}-q_{u,v-1}}{8}\]</div><p>This scheme will always converge to a solution however the rate of convergence may depend upon the initial solution. This implementation will initilize with a zero solution. Neumann boundary conditions are imposed at the edges where the scheme would otherwise go out of bounds.</p><p><strong>Parameters</strong></p><p>The function parameters are described in more detail below.</p><p><strong><code>Max_iter</code>:</strong></p><p>An <code>Int</code> which controls the number of iterations the algorithm will run for.</p><p><strong><code>ϵ</code>:</strong></p><p>A <code>Real</code> representing the distance between pixels. This will Control how tall the final reconstruction is relative the array grid.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>Horn</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Horn() integrator
horn = Horn(ϵ = 0.03, max_iter = 10000)

# Calculate the heightmap from the gradients
Z = horn(p, q)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>[1] B. Horn and M. Brooks, &quot;The variational approach to shape from shading&quot;, Computer Vision, Graphics, and Image Processing, vol. 33, no. 2, pp. 174-208, 1986. <a href="https://doi.org/10.1016/0734-189x(86)90114-3 ">doi: 10.1016/0734-189x(86)90114-3</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L262-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Durou-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Durou-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Durou</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Durou(ϵ::Real = 1.0, max_iter::Real = 1000)</code></pre><p>Implements the Durou and Courteille method of integrating surface normals. This algorithm offers an iterative solution to the Poisson equation describing the surface extending Horn and Brook&#39;s method by improving the boundary approximation and providing good reconstructions under most conditions.</p><p><strong>Output</strong></p><p><code>Durou()</code> returns a Durou integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>TheDurou and Courteille&#39;s method attempts to solve the Poisson equation <span>$\nabla^2z = \partial_up + \partial_vq$</span> by the discretization given below:</p><div>\[z_{u+1,v}+z_{u,v+1}-2z_{u,v}=\frac{p_{u+1,v}+p_{u,v}}{2}+\frac{q_{u,v+1}+q_{u,v}}{2}\]</div><p>Which can be rearranged to give the iterative scheme provided by:</p><div>\[z_{u,v}^{k+1}= \frac{z_{u+1,v}^k + z_{u,v+1}^k}{2} - \frac{p_{u+1,v}+p_{u,v}}{4} - \frac{q_{u,v+1}+q_{u,v}}{4}\]</div><p>This scheme will always converge to a solution however the rate of convergence may depend upon the initial solution. This implementation will initialize with a zero solution. Natural boundary conditions are imposed at the edges using the condition <span>$\partial_uz-p+\partial_v-q=0$</span>. Although faster then the Horn and Brook&#39;s method and better at handling boundaries, it can generate a worse solution under some conditions.</p><p><strong>Parameters</strong></p><p>The function parameters are described in more detail below.</p><p><strong><code>Max_iter</code>:</strong></p><p>An <code>Int</code> which controls the number of iterations the algorithm will run for. the range [0,1].</p><p><strong><code>ϵ</code>:</strong></p><p>A <code>Real</code> representing the distance between pixels. This will Control how tall the final reconstruction is relative the array grid.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>Durou</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Durou() integrator
durou = Durou(ϵ = 0.03, max_iter = 10000)

# Calculate the heightmap from the gradients
Z = durou(p, q)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Normal Integration: A Survey&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 576-593, 2017. <a href="https://doi.org/10.1007/s10851-017-0773-x ">doi: 10.1007/s10851-017-0773-x</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L351-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Quadratic-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Quadratic-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Quadratic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quadratic(z::AbstractArray, λ::AbstractArray = fill(10.0^-6, size(z)), mask::AbstractArray = fill(1.0, size(z)))</code></pre><p>Implements the quadratic variational least squared method proposed by Aujol, Durou and Quéau. The algorithm solves the least squares system generated from minimizing a fidelity term <span>$\mathcal{F}(z) = \iint_{(u,v)\in \Omega}\Phi(||\nabla z(u,v) - g(u,v)||)dudv$</span> and a regularization term <span>$\mathcal{R}(z) = \iint_{(u,v)\in \Omega}\lambda \left[z(u,v)-z^0(u,v)\right]^2dudv$</span> where <span>$\Phi(s) = s^2$</span>. This method is able to quickly produce good solutions on a smooth surface and can easily handle non-rectangular domains or sub-divided domains and can provide a good starting solution for other algorithms.</p><p><strong>Output</strong></p><p><code>Quadratic()</code> returns a Quadratic integrator which can then be called to run the quadratic method on a gradient field.</p><p><strong>Details</strong></p><p>As mentioned above the quadratic variational least squared method aims to minimize a fidelity term <span>$\mathcal{F}(z) = \iint_{(u,v)\in \Omega}\Phi(||\nabla z(u,v) - g(u,v)||)dudv$</span> and a regulization term <span>$\mathcal{R}(z) = \iint_{(u,v)\in \Omega}\lambda \left[z(u,v)-z^0(u,v)\right]^2dudv$</span> where <span>$\Phi(s) = s^2$</span>.</p><p>This leads to the minimization problem given by:</p><div>\[min\iint_{(u,v)\in \Omega}||\nabla z(u,v)-\mathbf{g}(u,v)||^2+\lambda(u,v)\left[z(u,v)-z^0(u,v)\right]^2dudv\]</div><p>By discretizing the problem we can arrive at the functional:</p><div>\[\begin{aligned}
E(z) = \frac{1}{2}\Big(\sum_{(u,v)\in \Omega_u^+}[\partial_u^+z_{u,v}-p_{u,v}]^2 \\+ \sum_{(u,v)\in \Omega_u^-}[\partial_u^-z_{u,v}-p_{u,v}]^2 \\+ \sum_{(u,v)\in \Omega_v^+}[\partial_v^+z_{u,v}-q_{u,v}]^2 \\+ \sum_{(u,v)\in \Omega_v^-}[\partial_v^-z_{u,v}-q_{u,v}]^2\Big) \\+ \sum_{(u,v)\in \Omega}[z_{u,v}-z^0_{u,v}]^2
\end{aligned}\]</div><p>where <span>$\Omega_u^+$</span> represents the domain where <span>$(u,v)\in\{(u,v)\in\Omega|(u,v)(u+1,v)\in\Omega\}$</span> etc.. Using this definition the discrete differences can be converted into matrix form, where <span>$p_{u,v}=z_{u+1,v}-z_{u,v}$</span> is the forward difference in the u direction etc. This data is then stacked into three vectors; <span>$\mathbf{z},\mathbf{p},\mathbf{q}\in\R^{|\Omega|}$</span>. Thus the matrix reresenting each of these is defined as below where m(i) is the mapping of the ith element of this vector to its corresponding point in <span>$(u,v)$</span> and <span>$D_u^+$</span> is a <span>$|\Omega|\times|\Omega|$</span> matrix.</p><div>\[D_u^+[i,j]=\begin{cases}
   0 &amp;\text{if } m(i)\notin\Omega_u^+ \text{or } j \ne i \text{or } j \ne i+1\\
   -1 &amp;\text{if } j = i \text {and } m(i)\in\Omega_u^+\\
   1 &amp;\text{if } j = i+1 \text {and } m(i)\in\Omega_u^+
\end{cases}\]</div><p>For a 2X2 domain this looks like:</p><div>\[D_u^+ = \begin{bmatrix}
   -1 &amp; 1 &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; -1 &amp; 1 \\
   0 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}\]</div><p>The other three discrete differences matrices are similarly defined from there definitions to be <span>$D_u^-$</span>, <span>$D_v^+$</span> and <span>$D_v^-$</span>. These can then be used to redefine the minimization problem to be in the form:</p><div>\[E(\mathbf{z})=\frac{1}{2}\left(||D_u^+\mathbf{z}-\mathbf{p}||^2+||D_u^-\mathbf{z}-\mathbf{p}||^2+||D_v^+\mathbf{z}-\mathbf{q}||^2+||D_v^-\mathbf{z}-\mathbf{q}||^2\right)+||\Lambda(\mathbf{z}-\mathbf{z}^0)||^2\]</div><p>Where <span>$\Lambda$</span> is the <span>$|\Omega|\times|\Omega|$</span> diagonal matrix containing the values of <span>$\sqrt{\lambda_{u,v}}$</span>. Using the above definitions the negative Laplacian matrix can then be defined as:</p><div>\[L=\frac{1}{2}[D_u^{+\top}D_u^++D_u^{-\top}D_u^-+D_v^{+\top}D_v^++D_v^{-\top}D_v^-]\]</div><p>Finally the least minimization problem can be represented in the form of a least squares problem of the form <span>$A\mathbf{z}=\mathbf{b}$</span> where:</p><div>\[\begin{gathered}
A=L+\Lambda^2\\
\mathbf{b}=\frac{1}{2}\left[D_u^{+\top}+D_u^{-\top}\right]\mathbf{p}+\frac{1}{2}\left[D_v^{+\top}+D_v^{-\top}\right]\mathbf{q}+\Lambda^2\mathbf{z}^0\\
=D_u\mathbf{p}+D_v\mathbf{q}+\Lambda^2\mathbf{z}^0
\end{gathered}\]</div><p>This system is then solved using a standard conjugate gradient algorithm where the initialization has only a slight impact on the runtime and no impact on the final solution. The algorithm provides good results on smooth surfaces but struggles in the presence of discontinuities.</p><p><strong>Parameters</strong></p><p><strong><code>z</code>:</strong></p><p>An <code>AbstractArray</code> which defines the value of <span>$z^0$</span> the initial solution and prior to be used in the regularization term. Must be provided.</p><p><strong><code>λ</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code>, defaulting to <span>$10.0^{-6}$</span> everywhere. This defines theregulization weight at each point. Large values will force the algorithm to keep the solution near to <span>$z^0$</span> at that position. Can be used to keep the solution near the initial solution or guide the solution to a certain known value at points (i.e. known maxima and minima). This value should be set uniformly small otherwise.</p><p><strong><code>mask</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code>, which guides the algorithm as to where the valid domain is. Values of <code>1</code> will be in the domain <span>$\Omega$</span> while other values will be ignored and set to <span>$z^0$</span>. This can be used to integrate over sub-domain or to segment the domain into parts. The <code>gen_mask()</code> funtion can be used to generate a mask which will remove non-integrable regions dramatically improving the solution under most condition at the cost of not integrating the entire solution.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>Quadratic</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(Prism(), radius = 75, img_size = 151)

# Create a Quadratic() integrator
quadratic = Quadratic(z=zeros(size(p)))
quadraticMasked = Quadratic(z=zeros(size(p)), mask=gen_mask(p,q,1.0)[:,:,1])

# Calculate the heightmap from the gradients
Z = quadratic(p, q)
Z2 = quadraticMasked(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)
Z2 = Z2./maximum(Z2)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
vbox(surface(r, r, Z), surface(r, r, Z2))</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Variational Methods for Normal Integration&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 609-632, 2017. <a href="https://doi.org/10.1007/s10851-017-0777-6 ">doi: 10.1007/s10851-017-0777-6</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L463-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.TotalVariation-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.TotalVariation-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.TotalVariation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TotalVariation(z::AbstractArray, α::Real = 1.0, λ::AbstractArray = fill(10.0^-6, size(z)), mask::AbstractArray = fill(1.0, size(z)), max_iter::Int = 100)</code></pre><p>Implements the total variational method proposed by Aujol, Durou and Quéau. The algorithm solves the same minimization problem as th <code>Quadratic</code>method exept the fidelity terms function <span>$\Phi(s)=||s||_{L_1}$</span>. This method is able to produce good solutions on a smooth and piecewise smooth surface and can easily handle non-rectangular domains or sub-divided domains.</p><p><strong>Output</strong></p><p><code>TotalVariation()</code> returns a TotalVariation integrator which can then be called to run the quadratic method on a gradient field.</p><p><strong>Details</strong></p><p>As discussed above this algorithm used the same fidelity and regularization terms as the <code>Quadratic</code> method exept the <span>$\Phi(s)=s^2$</span> term is replaced with <span>$\Phi(s)=||s||_{L_1}$</span>. This leads to the minimization problem defined by:</p><div>\[min\iint_{(u,v)\in \Omega}||\nabla z(u,v)-\mathbf{g}(u,v)||+\lambda(u,v)\left[z(u,v)-z^0(u,v)\right]^2dudv\]</div><p>By considering the four posible discreatisations of <span>$∇z(u,v)$</span> we can generate four posible domains to consider given by; <span>$\Omega^{UV}=\Omega_u^U\cup\Omega_v^V, (U,V)\in\{+,-\}^2$</span> where <span>$\{+,-\}^2$</span> refers to all posible combinations of +,-. Using these the following discreate functional can be generated:</p><div>\[\begin{aligned}
E(\mathbf{z})=\frac{1}{4}\Big(&amp;\sum_{(u,v)\in\Omega^{++}}\sqrt{[\partial_u^+z_{u,v}-p_{u,v}]^2+[\partial_v^+z_{u,v}-q_{u,v}]^2}\\
+&amp;\sum_{(u,v)\in\Omega^{+-}}\sqrt{[\partial_u^+z_{u,v}-p_{u,v}]^2+[\partial_v^-z_{u,v}-q_{u,v}]^2}\\
+&amp;\sum_{(u,v)\in\Omega^{-+}}\sqrt{[\partial_u^-z_{u,v}-p_{u,v}]^2+[\partial_v^+z_{u,v}-q_{u,v}]^2}\\
+&amp;\sum_{(u,v)\in\Omega^{--}}\sqrt{[\partial_u^-z_{u,v}-p_{u,v}]^2+[\partial_v^-z_{u,v}-q_{u,v}]^2}\Big)\\
+&amp;\sum_{(u,v)\in\Omega}\lambda_{u,v}\left[z_{u,v}-z^0_{u,v}\right]^2
\end{aligned}\]</div><p>Which simplifies to the minimization problem:</p><div>\[\begin{gathered}
min\frac{1}{4}\sum_{(U,V)\in\{+,-\}^2}\sum_{(u,v)\in\Omega^{UV}}||\mathbf{r}_{(u,v)}^{UV}||+\sum_{(u,v)\in\Omega}\lambda_{u,v}\left[z_{u,v}-z^0_{u,v}\right]^2\\
\mathbf{r}_(u,v)^{UV}=\nabla^{UV}z_{u,v}-\mathbf{g}_{u,v}
\end{gathered}\]</div><p>This leads to the optimization scheme using an ADMM algorithm defined by:</p><div>\[\begin{aligned}
z^{(k+1)}=&amp;min\frac{\alpha}{8}\sum_{(U,V)\in\{+,-\}^2}\sum_{(u,v)\in\Omega^{UV}}||\nabla^{UV}z_{u,v}-(\mathbf{g}_{u,v}+\mathbf{r}_{(u,v)}^{UV^{(k)}}-\mathbf{b}_{(u,v)}^{UV^{(k)}})||\\&amp;+\sum_{(u,v)\in\Omega}\lambda_{u,v}\left[z_{u,v}-z^0_{u,v}\right]^2\\
\mathbf{r}_{(u,v)}^{UV^{(k+1)}}=&amp;min\frac{\alpha}{8}||\mathbf{r}-(\nabla^{UV}z_{u,v}-\mathbf{g}_{u,v}+\mathbf{b}_{(u,v)}^{UV^{(k)}})||+||\mathbf{r}||\\
\mathbf{b}_{(u,v)}^{UV^{(k+1)}}=&amp;\mathbf{b}_{(u,v)}^{UV^{(k)}})+\nabla^{UV}z_{u,v}-\mathbf{g}_{u,v}-\mathbf{r}_{(u,v)}^{UV^{(k+1)}}
\end{aligned}\]</div><p>The z update then can be solved using the linear system defined below, where D_{u,v}^{U,V} and <span>$\Lambda$</span> are the same at those defined in <a href="#ShapeFromShading.Quadratic-Tuple{AbstractArray,AbstractArray}"><code>Quadratic</code></a>.</p><div>\[\begin{aligned}
    A_{TV}&amp;\mathbf{z}^{(k+1)}=b_{TV}^{(k)}\\
    A_{TV}&amp;=\frac{\alpha}{8}\sum_{(U,V)\in\{+,-\}^2}\left[D_u^{U\top}D_u^{U}+D_v^{V\top}D_v^{V}\right] + \Lambda^2\\
    b_{TV}^{(k)}&amp;=\frac{\alpha}{8}\sum_{(U,V)\in\{+,-\}^2}\left[D_u^{U\top}\mathbf{P}^{UV^{(k)}} + D_v^{V\top}\mathbf{Q}^{UV^{(k)}}\right]+ \Lambda^2\mathbf{z}^0\\
\end{aligned}\]</div><p>Where <span>$\mathbf{P}^{UV^{(k)}}, \mathbf{Q}^{UV^{(k)}}$</span> are the u and v components of <span>$\mathbf{g}+\mathbf{r}^{UV^{(k)}}-\mathbf{b}^{UV^{(k)}}$</span>. This can be solved using conjugate gradient. Finally the update to <span>$\mathbf{r}^{UV}$</span> can be computed as:</p><div>\[\begin{aligned}
    \mathbf{r}^{UV^{(k+1)}}&amp;=max\Big\{||\mathbf{s}_{u,v}^{UV^{(k+1)}}||-\frac{4}{\alpha},0\Big\}\frac{\mathbf{s}_{u,v}^{UV^{(k+1)}}}{||\mathbf{s}_{u,v}^{UV^{(k+1)}}||}\\
    \text{Where:}&amp;\\
    \mathbf{s}^{UV^{(k+1)}}&amp;=\nabla^{UV}z_{u,v}^{(k+1)}-\mathbf{g}_{u,v}+\mathbf{b}_{u,v}^{UV^{(k)}}
\end{aligned}\]</div><p><strong>Parameters</strong></p><p><strong><code>z</code>:</strong></p><p>An <code>AbstractArray</code> which defines the value of <span>$z^0$</span> the initial solution and prior to be used in the regulization term. Must be provided.</p><p><strong><code>α</code>:</strong></p><p>A <code>Real</code> with defult value of <code>1.0</code> which controls the step size. In theory this value should have no impact on final solution but in practice larger values can lead to worse solutions while values which are two small may lead non-convergance in the least square update step, causing the algorithm to hang for long periods of time. Values below <code>0.25</code> are not recomended but may work depending on domain size and inputs.</p><p><strong><code>λ</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code> defulting to <span>$10.0^{-6}$</span> everywhere. This defines theregulization weight at each point. Large valueas will force the algorithm to keep the solution near to <span>$z^0$</span> at that position. Can be used to keep the solution near the initial solution or guide the solution to a certian known value at points (i.e. known maxima and minima). This value should be set uniformly small otherwise.</p><p><strong><code>mask</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code>, which guides the algorithm as to where the valid domain is. Values of <code>1</code> will be in the domain <span>$\Omega$</span> while other values will be ignored and set to <span>$z^0$</span>. This can be used to integrate over sub-domain or to segment the domain into parts. The <code>gen_mask()</code> funtion can be used to generate a mask which will remove non-integrable regions dramatically improving the solution under most condition at the cost of not integrating the entire solution.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>TotalVariation</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(Prism(), radius = 75, img_size = 151)

# Create a TotalVariation() integrator
totalVariation = TotalVariation(z=zeros(size(p)), α=1.0)
totalVariationMasked = TotalVariation(z=zeros(size(p)), α=0.5, mask=gen_mask(p,q,1.0)[:,:,1])

# Calculate the heightmap from the gradients
Z = totalVariation(p, q)
Z2 = totalVariationMasked(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)
Z2 = Z2./maximum(Z2)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
vbox(surface(r, r, Z), surface(r, r, Z2))</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Variational Methods for Normal Integration&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 609-632, 2017. <a href="https://doi.org/10.1007/s10851-017-0777-6 ">doi: 10.1007/s10851-017-0777-6</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L643-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.NonConvex1-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.NonConvex1-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.NonConvex1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NonConvex1(z::AbstractArray, β::Real = 0.5, λ::AbstractArray = fill(10.0^-6, size(z)), mask::AbstractArray = fill(1.0, size(z)), max_iter::Int = 100)</code></pre><p>The first of two non-convex regularization methods proposed by Aujol, Durou and Quéau. The same fidelity and regularization terms to minimize as <a href="#ShapeFromShading.Quadratic-Tuple{AbstractArray,AbstractArray}"><code>Quadratic</code></a> are used, but the convexity of <span>$\Phi$</span> is sacrificed in order to gain better behaviour around discontinuities and outliers.</p><p><strong>Output</strong></p><p><code>NonConvex1()</code> returns a NonConvex1 integrator which can then be called to run the non-convex regularization method method on a gradient field.</p><p><strong>Details</strong></p><p>The initial minimization problem is the same as in <a href="#ShapeFromShading.TotalVariation-Tuple{AbstractArray,AbstractArray}"><code>TotalVariation</code></a> as given below exept <span>$Phi$</span> is defined using the given function instead of the <span>$L_1$</span> norm.</p><div>\[\begin{aligned}
&amp;min\iint_{(u,v)\in \Omega}||\nabla z(u,v)-\mathbf{g}(u,v)||+\lambda(u,v)\left[z(u,v)-z^0(u,v)\right]^2dudv\\
&amp;\text{where:}\\
&amp;\Phi(s)=log(s^2+\beta^2)
\end{aligned}\]</div><p>The problem can then be discretized to form the following functional where <span>$D_{u,v}^{UV}$</span> is a <span>$2\times|\Omega|$</span> matrix formed from stacking the vectors of the finite diferences.</p><div>\[\begin{aligned}
E(\mathbf{z})&amp;=\frac{1}{4}\sum_{(U,V)\in\{+,-\}^2}\sum_{(u,v)\in\Omega^{UV}}\Phi(||\nabla z_{u,v}-\mathbf{g}_{u,v}||)+\sum_{(u,v)\in\Omega}\lambda_{u,v}\left[z_{u,v}-z^0_{u,v}\right]^2\\
&amp;=\frac{1}{4}\sum_{(U,V)\in\{+,-\}^2}\sum_{(u,v)\in\Omega^{UV}}\Phi(||D_{u,v}^{UV}\mathbf{z}-\mathbf{g}_{u,v}||)+||\Lambda\left(\mathbf{z}-\mathbf{z}^0\right)||^2\\
&amp;=f(\mathbf{z})+g(\mathbf{z})
\end{aligned}\]</div><p>As <span>$f(\mathbf{z})$</span> is smooth but not convex and <span>$g(\mathbf{z})$</span> is convex the iPiano algorithm is then used to iterativly solve the minimization of the functional such that:</p><div>\[\mathbf{z}^{(k+1)}=(I+\alpha_1\partial g)^{-1}(\mathbf{z}^{(k)}-\alpha_1\nabla f(\mathbf{z}^{(k)})+\alpha_2(\mathbf{z}^{(k)}-z^{(k+1)}))\]</div><p>where <span>$(I+\alpha_1\partial g)^{-1}$</span> is a proximal operator defined as:</p><div>\[(I+\alpha_1\partial g)^{-1}(\mathbf{\hat{x}})=(I+2\alpha_1\Lambda^2)^{-1}(\mathbf{\hat{x}}+2\alpha_1\Lambda\mathbf{z}^0)\]</div><p>Using the definition of <span>$\Phi$</span> given above, the derivative of <span>$f(\mathbf{z})$</span> can be computed as below:</p><div>\[\nabla f(\mathbf{z})=\frac{1}{4}\sum_{(U,V)\in\{+,-\}^2}\sum_{(u,v)\in\Omega^{UV}}\frac{D_{u,v}^{UV^\top}(D_{u,v}^{UV}\mathbf{z}-\mathbf{g}_{u,v})}{||D_{u,v}^{UV}\mathbf{z}-\mathbf{g}_{u,v}||^2+\beta^2}\]</div><p>The values of <span>$\alpha_1$</span> and <span>$\aplha_2$</span> control the step size of the algorith and are chosen such that <span>$\alpha_2$</span> is fixed at 0.8 while <span>$\alpha_1$</span> is chosen using the lazy backtracking method, which uses a Lipschitz constant to caculate a suitably small step size at each step using the below relationship where <span>$\eta&gt;1$</span> is a constant:</p><div>\[\begin{aligned}
&amp;\alpha_1 &lt; 2(1-\alpha_2)/L_n\\
&amp;\text{where:}\\
&amp;L_k\in\{L_{k-1},\eta L_{k-1},\eta^2L_{k-1},...\}\\
&amp;\text{such that it is minimal and satisfies:}\\
&amp;f(x^{(k+1)})\le f(x^{(k)}) + \left\langle\nabla f(x^{(k)}), x^{(k+1)}-x^{(k)}\right\rangle+\frac{L_k}{2}||x^{(k+1)}-x^{(k)}||^2
\end{aligned}\]</div><p>This method, being non-convex, highly relies on a good initial solution and will often only provide a minimal improvment to the solution. A bad initial solution will produce a final solution which does not resemble the surface under most conditions.</p><p><strong>Parameters</strong></p><p><strong><code>z</code>:</strong></p><p>An <code>AbstractArray</code> which defines the value of <span>$z^0$</span> the initial solution and prior to be used in the regulization term.</p><p><strong><code>β</code>:</strong></p><p>A <code>Real</code> which acts as a hyper-parameter to the function. Large values for β will produce smoother functions but loose discontinuities. Smaller value will preserve discontinuities but lead to staircassing in the solution. Defults to <code>0.5</code>.</p><p><strong><code>λ</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code> defulting to <span>$10.0^-6$</span> everywhere. This defines theregulization weight at each point. Large valueas will force the algorithm to keep the solution near to <span>$z^0$</span> at that position. Can be used to keep the solution near the initial solution or guide the solution to a certian known value at points (i.e. known maxima and minima). This value should be set uniformly small otherwise.</p><p><strong><code>mask</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code>, which guides the algorithm as to where the valid domain is. Values of <code>1</code> will be in the domain <span>$\Omega$</span> while other values will be ignored and set to <span>$z^0$</span>. This can be used to integrate over sub-domain or to segment the domain into parts. The <code>gen_mask()</code> funtion can be used to generate a mask which will remove non-integrable regions dramatically improving the solution under most condition at the cost of not integrating the entire solution.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>NonConvex1</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(Prism(), radius = 75, img_size = 151)

# Create a NonConvex1() integrator
nonConvex1 = NonConvex1(z=zeros(size(p)), β=0.5)
nonConvex1Init = NonConvex1(z=Horn()(p,q), β=0.5)

# Calculate the heightmap from the gradients
Z = nonConvex1(p, q)
Z2 = nonConvex1Init(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)
Z2 = Z2./maximum(Z2)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
vbox(surface(r, r, Z), surface(r, r, Z2))</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Variational Methods for Normal Integration&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 609-632, 2017. <a href="https://doi.org/10.1007/s10851-017-0777-6 ">doi: 10.1007/s10851-017-0777-6</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L901-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.NonConvex2-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.NonConvex2-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.NonConvex2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NonConvex2(z::AbstractArray, γ::Real = 1.0, λ::AbstractArray = fill(10.0^-6, size(z, mask::AbstractArray = fill(1.0, size(z)), max_iter::Int = 100)</code></pre><p>The second of two non-convex regularization methods proposed by Aujol, Durou and Quéau. The same as <a href="#ShapeFromShading.NonConvex1-Tuple{AbstractArray,AbstractArray}"><code>NonConvex1</code></a> exept <span>$\Phi$</span> has been replaced with a different non-convex function.</p><p><strong>Output</strong></p><p><code>NonConvex2()</code> returns a NonConvex2 integrator which can then be called to run the non-convex regularization method method on a gradient field.</p><p><strong>Details</strong></p><p>The implimentation is the same as the one in <a href="#ShapeFromShading.TotalVariation-Tuple{AbstractArray,AbstractArray}"><code>TotalVariation</code></a> as given below exept <span>$Phi$</span> is defined as below:</p><div>\[\Phi(s)=\frac{s^2}{s^2+\gamma^2}\]</div><p>Using the definition of <span>$\Phi$</span> given above, the derivative of <span>$f(\mathbf{z})$</span> can be computed as below:</p><div>\[\nabla f(\mathbf{z})=\frac{1}{4}\sum_{(U,V)\in\{+,-\}^2}\sum_{(u,v)\in\Omega^{UV}}\frac{\gamma^2D_{u,v}^{UV^\top}(D_{u,v}^{UV}\mathbf{z}-\mathbf{g}_{u,v})}{()||D_{u,v}^{UV}\mathbf{z}-\mathbf{g}_{u,v}||^2+\gamma^2)^2}\]</div><p>This method, being non-convex, highly relies on a good initial solution and will often only provide a minimal improvment to the solution. A bad initial solution will produce a final solution which does not resemble the surface under most conditions.</p><p><strong>Parameters</strong></p><p><strong><code>z</code>:</strong></p><p>An <code>AbstractArray</code> which defines the value of <span>$z^0$</span> the initial solution and prior to be used in the regulization term.</p><p><strong><code>γ</code>:</strong></p><p>A <code>Real</code> which acts as a hyper-parameter to the function. Large values for γ will produce smoother functions but loose discontinuities. Smaller value will preserve discontinuities but lead to staircassing in the solution. Defults to <code>1.0</code>.</p><p><strong><code>λ</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code> defulting to <span>$10.0^-6$</span> everywhere. This defines theregulization weight at each point. Large valueas will force the algorithm to keep the solution near to <span>$z^0$</span> at that position. Can be used to keep the solution near the initial solution or guide the solution to a certian known value at points (i.e. known maxima and minima). This value should be set uniformly small otherwise.</p><p><strong><code>mask</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code>, which guides the algorithm as to where the valid domain is. Values of <code>1</code> will be in the domain <span>$\Omega$</span> while other values will be ignored and set to <span>$z^0$</span>. This can be used to integrate over sub-domain or to segment the domain into parts. The <code>gen_mask()</code> funtion can be used to generate a mask which will remove non-integrable regions dramatically improving the solution under most condition at the cost of not integrating the entire solution.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>NonConvex2</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(Prism(), radius = 75, img_size = 151)

# Create a NonConvex2() integrator
nonConvex2 = NonConvex2(z=zeros(size(p)), γ=1.0)
nonConvex2Init = NonConvex2(z=Horn()(p,q), γ=1.0)

# Calculate the heightmap from the gradients
Z = nonConvex2(p, q)
Z2 = nonConvex2Init(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)
Z2 = Z2./maximum(Z2)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
vbox(surface(r, r, Z), surface(r, r, Z2))</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Variational Methods for Normal Integration&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 609-632, 2017. <a href="https://doi.org/10.1007/s10851-017-0777-6 ">doi: 10.1007/s10851-017-0777-6</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L1090-L1164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.AnisotropicDiffusion-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.AnisotropicDiffusion-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.AnisotropicDiffusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AnisotropicDiffusion(z::AbstractArray, μ::Real = 5.0, ν::Real = 10., λ::AbstractArray = fill(10.0^-6, size(z)), mask::AbstractArray = fill(1.0, size(z)), max_iter::Int = 10)</code></pre><p>Defines the anisotropic diffusion method as proposed by Aujol, Durou and Quéau. It utilizes an anisotropic diffusion like process to create a weighted version of the least squares problem solved in the <a href="#ShapeFromShading.Quadratic-Tuple{AbstractArray,AbstractArray}"><code>Quadratic</code></a> method.</p><p><strong>Output</strong></p><p><code>AnisotropicDiffusion()</code> returns a AnisotropicDiffusion integrator which can then be called to run the anisotropic diffusion method method on a gradient field.</p><p><strong>Details</strong></p><p>The minimization problem from <a href="#ShapeFromShading.Quadratic-Tuple{AbstractArray,AbstractArray}"><code>Quadratic</code></a> is modified with the addition weighting term <span>$W(u,v)$</span> to reach the following minimization problem.</p><div>\[min\iint_{(u,v)\in \Omega}||W(u,v)[\nabla z(u,v)-\mathbf{g}(u,v)]||^2+\lambda(u,v)\left[z(u,v)-z^0(u,v)\right]^2dudv\]</div><p>The weighting term can be defined as below where <span>$\mu$</span> and <span>$\nu$</span> are parameters which control the impact of gradient of the reconstruction at each iteration and the input gradients.</p><div>\[W(u,v)=\frac{1}{\sqrt{\left(\frac{||\nabla z(u,v)||}{\mu}\right)^2+1}}\begin{bmatrix}\frac{1}{\sqrt{1+\left(\frac{p(u,v)}{\nu}\right)^2}} &amp;0\\ 0 &amp;\frac{1}{\sqrt{1+\left(\frac{q(u,v)}{\nu}\right)^2}}\end{bmatrix}\]</div><p>This lends itself to the creation of the terms <span>$A^{UV}$</span> and <span>$B^{UV}$</span> which are <span>$|\Omega|\times|\Omega|$</span> diagonal matrices, respectively,  contianing the values of;</p><div>\[    \frac{1}{\sqrt{1+\left(\frac{p(u,v)}{\nu}\right)^2}\sqrt{\frac{(\partial^U_uz_{u,v})^2+(\partial^V_vz_{u,v})^2}{\mu^2}+1}}\]</div><p>and</p><div>\[    \frac{1}{\sqrt{1+\left(\frac{q(u,v)}{\nu}\right)^2}\sqrt{\frac{(\partial^U_uz_{u,v})^2+(\partial^V_vz_{u,v})^2}{\mu^2}+1}}\]</div><p>where <span>$(U,V)\in\{+,-\}^2$</span>. Using these definititions the original minimization problem can be rewriten as the following iterative scheme:</p><div>\[\begin{aligned}
z^{(k+1)}=&amp;min\frac{1}{4}\sum_{(U,V)\in\{+,-\}^2}\left\{||A^{UV}(D^U_u\mathbf{z}-\mathbf{p})||^2+||B^{UV}(D^V_v\mathbf{z}-\mathbf{q})||^2\right\}\\
&amp;+||\Lambda(\mathbf{z}-\mathbf{z}^0)||
\end{aligned}\]</div><p>which is then solved using Cholesky factorization.</p><p><strong>Parameters</strong></p><p><strong><code>z</code>:</strong></p><p>An <code>AbstractArray</code> which defines the value of <span>$z^0$</span> the initial solution and prior to be used in the regulization term.</p><p><strong><code>μ</code>:</strong></p><p>A <code>Real</code> which acts as a hyper-parameter to the function. Allows for the tuning of discontinuities. Defults to <code>5.0</code>.</p><p><strong><code>ν</code>:</strong></p><p>A <code>Real</code> which acts as a hyper-parameter to the function. Allows for the tuning of discontinuities. Unlike <code>μ</code> is has a minimal impact on the solution and generally does not need adjusting unless an extreme value for <code>μ</code> is used where it can help to balance out the two terms. Defults to <code>10.0</code>.</p><p><strong><code>λ</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code> defulting to <span>$10.0^-6$</span> everywhere. This defines theregulization weight at each point. Large valueas will force the algorithm to keep the solution near to <span>$z^0$</span> at that position. Can be used to keep the solution near the initial solution or guide the solution to a certian known value at points (i.e. known maxima and minima). This value should be set uniformly small otherwise.</p><p><strong><code>mask</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code>, which guides the algorithm as to where the valid domain is. Values of <code>1</code> will be in the domain <span>$\Omega$</span> while other values will be ignored and set to <span>$z^0$</span>. This can be used to integrate over sub-domain or to segment the domain into parts. The <code>gen_mask()</code> funtion can be used to generate a mask which will remove non-integrable regions dramatically improving the solution under most condition at the cost of not integrating the entire solution.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>AnisotropicDiffusion</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(Prism(), radius = 75, img_size = 151)

# Create a AnisotropicDiffusion() integrator
anisotropicDiffusion = AnisotropicDiffusion(z=zeros(size(p)), γ=1.0)
anisotropicDiffusionInit = AnisotropicDiffusion(z=Horn()(p,q), γ=1.0)

# Calculate the heightmap from the gradients
Z = anisotropicDiffusion(p, q)
Z2 = anisotropicDiffusionInit(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)
Z2 = Z2./maximum(Z2)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
vbox(surface(r, r, Z), surface(r, r, Z2))</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Variational Methods for Normal Integration&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 609-632, 2017. <a href="https://doi.org/10.1007/s10851-017-0777-6 ">doi: 10.1007/s10851-017-0777-6</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L1239-L1333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.MumfordShah-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.MumfordShah-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.MumfordShah</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MumfordShah(z::AbstractArray, μ::Real = 10.0, ϵ::Real = 0.1, λ::AbstractArray = fill(10.0^-6, size(z, mask::AbstractArray = fill(1.0, size(z)), max_iter::Int = 50)</code></pre><p>Defines the Mumford-Shah method, the final method proposed by Aujol, Durou and Quéau. It utilizes an adepted version of Mumford and Shah functional to provide a good reconstruction in the presence of discontinuities at the const of a longer runtime then other methods.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function can take several minutes to run on grids larger then 64X64.</p></div></div><p><strong>Output</strong></p><p><code>MumfordShah()</code> returns a MumfordShah integrator which can then be called to run the Mumford-Shah method method on a gradient field.</p><p><strong>Details</strong></p><p>This method involves modifying the minimization problem given by the Mumford and Shah functional given below:</p><div>\[min\;\mu\iint_{(u,v)\in\Omega\backslash K}||\nabla z(u,v)||dudv+\int_Kd\sigma\\+\lambda\iint_{(u,v)\in\Omega\backslash K}[z(u,v)-z^0(u,v)]^2dudv\]</div><p>Where <span>$K$</span> is the set of discontinuities. This can then be adapted to our problem by utilizing a Ambrosio-Tortelli approximation to achaive the following functional where <span>$\epsilon\to0$</span>.</p><div>\[\begin{aligned}
E(z)=\mu&amp;\iint_{(u,v)\in\Omega}w(u,v)^2||\nabla z(u,v)-\mathbf{g}(u,v)||^2dudv\\
+&amp;\iint_{(u,v)}\left[\epsilon||\nabla w(u,v)||^2+\frac{1}{4\epsilon}(w(u,v)-1)^2\right]dudv\\
+&amp;\iint_{(u,v)}\lambda(u,v)\left[z(u,v)-z^0(u,v)\right]dudv
\end{aligned}\]</div><p>This leads to the following discretization of the functional where <span>$\mathbf{w}^{+/-}_{u/v}$</span> are thevecotr of weights in each forward and backward direction and the matrix <span>$W^{+/-}_{u/v}$</span> is the diagonal matrix formed from this vector.</p><div>\[\begin{aligned}
E(\mathbf{z},\mathbf{w}^{+}_{u},\mathbf{w}^{-}_{u},\mathbf{w}^{+}_{v},\mathbf{w}^{-}_{v})&amp;=\frac{\mu}{2}\Big(||W^+_u(D^+_u\mathbf{z}-\mathbf{p})||^2+||W^-_u(D^-_u\mathbf{z}-\mathbf{p})||^2\\
&amp;+||W^+_v(D^+_v\mathbf{z}-\mathbf{q})||^2+||W^-_v(D^-_v\mathbf{z}-\mathbf{q})||^2\Big)\\
&amp;+\frac{\epsilon}{2}\Big(||D^+_u\mathbf{w}^{+}_{u}||^2+||D^-_u\mathbf{w}^{-}_{u}||^2+||D^+_v\mathbf{w}^{+}_{v}||^2\\
&amp;+||D^-_v\mathbf{w}^{-}_{v}||^2\Big)+\frac{1}{8\epsilon}\Big(||\mathbf{w}^{+}_{u}-\mathbf{1}||^2+||\mathbf{w}^{-}_{u}-\mathbf{1}||^2\\
&amp;+||\mathbf{w}^{+}_{v}-\mathbf{1}||^2+||\mathbf{w}^{-}_{v}-\mathbf{1}||^2\Big)+||\Lambda(\mathbf{z}-\mathbf{z}^0)||^2
\end{aligned}\]</div><p>This is then solved with a conjugate gradient algorithm and an alternating optimization scheme at each step where the updates are found using the relationships below:</p><div>\[\begin{gathered}
\mathbf{z}^{(k+1)}=min\;E(\mathbf{z}^{(k)},\mathbf{w}^{+(k)}_{u},\mathbf{w}^{-(k)}_{u},\mathbf{w}^{+(k)}_{v},\mathbf{w}^{-(k)}_{v})\\
\mathbf{w}^{+/-(k+1)}_{u/v}=min\;E(\mathbf{z}^{(k+1},\mathbf{w}^{+(k)}_{u},\mathbf{w}^{-(k)}_{u},\mathbf{w}^{+(k)}_{v},\mathbf{w}^{-(k)}_{v})\\
\end{gathered}\]</div><p>This method can produce good results if the parameters are appropriotly tuned. If the parameters are too large the solution will suffer heavily from staircasing artifacts while setting it too small will result in a smooth solution. Even if the value is chosen correctly the algorithm tends to overfit the final solution to the discontinuities and they will extend into parts of the solution which are actually smooth.</p><p><strong>Parameters</strong></p><p><strong><code>z</code>:</strong></p><p>An <code>AbstractArray</code> which defines the value of <span>$z^0$</span> the initial solution and prior to be used in the regulization term.</p><p><strong><code>ϵ</code>:</strong></p><p>A <code>Real</code> which acts as a hyper-parameter to the function. Controls how the final solution will converge. Large values will lead to staircasing while small values will over-smooth the surface. Must be relativly small to achieve convergence to a solution. Defults to <code>0.1</code>.</p><p><strong><code>μ</code>:</strong></p><p>A <code>Real</code> which acts as a hyper-parameter to the function. This value controls the smoothness of the final solution. Large values will lead to staircasing while small values will lead to over-smoothed solutions. Defults to <code>10.0</code>.</p><p><strong><code>λ</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code> defulting to <span>$10.0^-6$</span> everywhere. This defines the regulization weight at each point. Large values will force the algorithm to keep the solution near to <span>$z^0$</span> at that position. Can be used to keep the solution near the initial solution or guide the solution to a certian known value at points (i.e. known maxima and minima). This value should be set uniformly small otherwise.</p><p><strong><code>mask</code>:</strong></p><p>An <code>AbstractArray</code> the same size as <code>z</code>, which guides the algorithm as to where the valid domain is. Values of <code>1</code> will be in the domain <span>$\Omega$</span> while other values will be ignored and set to <span>$z^0$</span>. This can be used to integrate over sub-domain or to segment the domain into parts. The <code>gen_mask()</code> funtion can be used to generate a mask which will remove non-integrable regions dramatically improving the solution under most condition at the cost of not integrating the entire solution.</p><p><strong>Example</strong></p><p>The following example demonstrates the use of the <code>MumfordShah</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(Prism(), radius = 75, img_size = 151)

# Create a MumfordShah() integrator
mumfordShah = MumfordShah(z=zeros(size(p)), γ=1.0)
mumfordShahInit = MumfordShah(z=Horn()(p,q), γ=1.0)

# Calculate the heightmap from the gradients
Z = mumfordShah(p, q)
Z2 = mumfordShahInit(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)
Z2 = Z2./maximum(Z2)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
vbox(surface(r, r, Z), surface(r, r, Z2))</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Variational Methods for Normal Integration&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 609-632, 2017. <a href="https://doi.org/10.1007/s10851-017-0777-6 ">doi: 10.1007/s10851-017-0777-6</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/integration.jl#L1417-L1526">source</a></section></article><h2 id="Shape-From-Shading:-1"><a class="docs-heading-anchor" href="#Shape-From-Shading:-1">Shape From Shading:</a><a class="docs-heading-anchor-permalink" href="#Shape-From-Shading:-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.DiscreteShape-Tuple{AbstractArray}" href="#ShapeFromShading.DiscreteShape-Tuple{AbstractArray}"><code>ShapeFromShading.DiscreteShape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Z,p,q = retrieve_surface(algorithm::DiscreteShape, img::AbstractArray, iterations::Int=2000)</code></pre><p>Attempts to produce a heightmap from a grayscale image by minimization of a set of Euler-Lagrange equations. This is done discretely at each point in the image utilizing the second derivates of the surface normals and their Fourier Transforms.</p><p><strong>Output</strong></p><p>Returns an M by N array of Float <code>Z</code> that represents the reconstructed height at the point and the gradients in M by N arrays of Float &#39;p&#39; and &#39;q&#39;.</p><p><strong>Details</strong></p><p>The algorithm attempts to minimise the brightness deviation <span>$ϵ$</span> through the brightness constraint <span>$\epsilon_1$</span> and smoothness constraint <span>$\epsilon_2$</span> as defined bellow:</p><div>\[\epsilon=\iint((\epsilon_1+\lambda\epsilon_2))dxdy=\iint((E(x,y)-R(p,q))^2+
\lambda(p_x^2+q_x^2+p_y^2+q_y^2))\]</div><p>This is minimised using the Euler-Lagrange equations defined as;</p><div>\[\dfrac{\delta\epsilon}{\delta p}-\dfrac{\delta}{\delta x}\dfrac{\delta\epsilon}{
\delta p_x}-\dfrac{\delta}{\delta y}\dfrac{\delta\epsilon}{\delta p_y}=0\]</div><p>and</p><div>\[\dfrac{\delta
\epsilon}{\delta q}-\dfrac{\delta}{\delta x}\dfrac{\delta\epsilon}{\delta q_x}-
\dfrac{\delta}{\delta y}\dfrac{\delta\epsilon}{\delta q_y}=0\]</div><p>which become:</p><div>\[\begin{gathered}
-2(E-R)\dfrac{\delta R}{\delta p}-2\lambda p_{xx}-2\lambda p_{yy}=0\\
-2(E-R)\dfrac{\delta R}{\delta p}-2\lambda q_{xx}-2\lambda q_{yy}=0
\end{gathered}\]</div><p>which can be further simplified to give:</p><div>\[\begin{gathered}
\nabla^2p=\dfrac{1}{\lambda}(R-E)\dfrac{\delta R}{\delta p}\\
\nabla^2q=\dfrac{1}{\lambda}(R-E)\dfrac{\delta R}{\delta q}
\end{gathered}\]</div><p>where <span>$\nabla^2p=p_{xx}+p_{yy}$</span> and <span>$\nabla^2q=q_{xx}+q_{yy}$</span> are Laplacians of p and q.</p><p>However, for computation we are dealing with a discreate case of these equations which can be defined as below:</p><div>\[\begin{gathered}
p_{i,j}=\bar{p}_{i,j}+\dfrac{1}{4\lambda}(E-R)\dfrac{\delta R}{\delta p}\\q_{i,j}=
\bar{q}_{i,j}+\dfrac{1}{4\lambda}(E-R)\dfrac{\delta R}{\delta q}\\
\end{gathered}\]</div><p>where</p><div>\[\bar{p}_{i,j}=\dfrac{p_{i+1,j}+p_{i-1,j}+p_{i,j+1}+p_{i,j-1}}{4}\]</div><p>and</p><div>\[\bar{q}_{i,j}=\dfrac{q_{i+1,j}+q_{i-1,j}+q_{i,j+1}+q_{i,j-1}}{4}\]</div><p>Finally, the algorithm needs to enforce integrability on p and q and retrieve the surface Z. This can be done by taking the Fast Fourier Transform of p and q ()<span>$c_p(\omega_x,\omega_y)$</span> and <span>$c_q(\omega_x,\omega_y)$</span>) and then using the Inverse Fast Fourier Transform to recover Z and update p and q as per bellow:</p><div>\[\begin{gathered}
p=\sum c_p(\omega_x,\omega_y)e^{j(\omega_xx+\omega_yy)}\\
q=\sum c_q(\omega_x,\omega_y)e^{j(\omega_xx+\omega_yy)}\\Z=\sum c(\omega_x,\omega_y)
e^{j(\omega_xx+\omega_yy)}\\
\end{gathered}\]</div><p>where</p><div>\[c(\omega_x,\omega_y)=\dfrac{-j(\omega_xc_p(\omega_x,\omega_y)+\omega_yc_q(\omega_x
,\omega_y))}{\omega_x^2+\omega_y^2}\]</div><p>The <code>albedo</code> and <code>illumination_direction</code> can be manually defined using the function signature:</p><pre><code class="language-none">Z,p,q = retrieve_surface(algorithm::DiscreteShape, img::AbstractArray, albedo::Real, illumination_direction::Vector{T} where T &lt;: Real, iterations::Int=2000)</code></pre><p>Note: if <code>albedo</code> and <code>illumination_direction</code> are not supplied they will be calculated at runtime using <code>estimate_img_properties</code>.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>img</code></strong></p><p>An <code>AbstractArray</code> storing the grayscale value of each pixel within the range [0,1].</p><p><strong><code>albedo</code></strong></p><p>A <code>Real</code> that specifies the albedo (amount of light reflected) of the image. If <code>albedo</code> is specified to must the <code>illumination_direction</code>.</p><p><strong><code>illumination_direction</code></strong></p><p>A <code>Vector{T} where T &lt;: Real</code> that specifies the tilt value to be used by the algorithm. The <code>illumination_direction</code> should be a vector of the form [x,y,z] where x,y,z are int he range [0,1]. If <code>illumination_direction</code> is specified to must the <code>albedo</code>.</p><p><strong><code>iterations</code></strong></p><p>An <code>Int</code> that specifies the number of iterations the algorithm is to perform. If left unspecified a default value of 2000 is used.</p><p><strong><code>smoothness</code></strong></p><p>An <code>Int</code> that specifies the strength of the smoothness constraint in the minimised function.</p><p><strong>Example</strong></p><p>Compute the heightmap for a synthetic image generated by <code>generate_surface</code>.</p><pre><code class="language-julia">using Images, Makie, ShapeFromShading

#generate synthetic image
img = generate_surface(SynthSphere(), 1, [0.2,0,0.9], radius = 5)

#calculate the heightmap (using 500 iterations)
Z,p,q = retrieve_surface(DiscreteShape(), img, 500)

#normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

#display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:2
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><ol><li>S. Elhabian, &quot;Hands on Shape from Shading&quot;, Computer Vision and Image Processing, 2008.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/discreteshape.jl#L1-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.DiscreteShapeBound-Tuple{AbstractArray}" href="#ShapeFromShading.DiscreteShapeBound-Tuple{AbstractArray}"><code>ShapeFromShading.DiscreteShapeBound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Z,p,q = retrieve_surface(algorithm::DiscreteShapeBound, img::AbstractArray, iterations::Int=2000)</code></pre><p>Same as <a href="#ShapeFromShading.DiscreteShape-Tuple{AbstractArray}"><code>DiscreteShape</code></a> except it has its initial conditions bound by the image as per bellow where <span>$E$</span> is the brightness of the image:</p><div>\[\begin{gathered}
Z_{i,j}=\begin{cases}-100E_{i,j} &amp;\text{if } E_{i,j}&gt;0.75\\0 &amp;\text{otherwise}\\
\end{cases}\\\\p,q=\nabla E
\end{gathered}\]</div><p><strong>Example</strong></p><p>Compute the heightmap for a synthetic image generated by <code>generate_surface</code>.</p><pre><code class="language-julia">using Images, Makie, ShapeFromShading

#generate synthetic image
img = generate_surface(SynthSphere(), 1, [0.2,0,0.9], radius = 5)

#calculate the heightmap (using 500 iterations)
Z,p,q = retrieve_surface(DiscreteShapeBound(), img, 500)

#normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

#display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:2
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><ol><li>S. Elhabian, &quot;Hands on Shape from Shading&quot;, Computer Vision and Image Processing, 2008.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/discreteshapebound.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Pentland-Tuple{AbstractArray}" href="#ShapeFromShading.Pentland-Tuple{AbstractArray}"><code>ShapeFromShading.Pentland</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Z = retrieve_surface(algorithm::Pentland, img::AbstractArray)</code></pre><p>Attempts to produce a heightmap from a grayscale image using Pentland&#39;s algorithm.</p><p>Under the assumptions of Lambertian surface, orthographic projections, the surface being illuminated by distant light sources, the surface is not self-shadowing and the surface has constant albedo, hence it can be ignored. The algorithm employs Tayler series expansion and Fourier transforms to compute a non-iterative solution.</p><p><strong>Output</strong></p><p>Returns an M by N array (matching dimensions of original image) of Float <code>Z</code> that represents the reconstructed height at the point.</p><p><strong>Details</strong></p><p>In Pentlands algorithm the image irradiance is defined as:</p><div>\[E(x,y)=R(p,q)=\dfrac{\rho(i_xp+i_yq-i_z)}{\sqrt{1+p^2+q^2}}=\dfrac{p\sin\sigma\cos
\tau+q\sin\sigma\sin\tau+\cos\sigma}{\sqrt{1+p^2+q^2}}\]</div><p>This can be reduced using the Taylor series expansion about <span>$p=p_0$</span> and <span>$p=p_0$</span> and ignoring the higher order terms becomes:</p><div>\[E(x,y)=R(p,q)\approx R(p_0,q_0)+(p-p_0)\dfrac{\delta R}{\delta p}(p_0,q_0)+(q-q_0)
\dfrac{\delta R}{\delta q}(p_0,q_0)\]</div><p>which for <span>$p_0=q_0=0$</span> further reduces to:</p><div>\[E(x,y)\approx\cos\sigma+p\cos\tau\sin\sigma+q\sin\tau\sin\sigma\]</div><p>This gives the following transform identities:</p><div>\[\begin{gathered}
p=\dfrac{\delta}{\delta x}Z(x,y)\xleftrightarrow{\Im}(-j\omega_x)F_z(
\omega_x,\omega_y)\\q=\dfrac{\delta}{\delta y}Z(x,y)\xleftrightarrow{\Im}(-j
\omega_y)F_z(\omega_x,\omega_y)
\end{gathered}\]</div><p>By taking the Fourier transform of both sides if <span>$E(x,y)$</span> yields the following:</p><div>\[F_E=(-j\omega_x)F_z(\omega_x,\omega_y)\cos\tau\sin\sigma+(-j\omega_y)F_z(\omega_x
,\omega_y)\sin\tau\sin\sigma\]</div><p>where <span>$F_z$</span> is the Fourier transform of <span>$Z(x,y)$</span>.</p><p>These can be rearranged, and the Inverse Fourier transform used to recover the surface <span>$Z(x,y)$</span> as per the following:</p><div>\[\begin{gathered}
F_E=F_z(\omega_x,\omega_y)[-j\omega_x\cos\tau\sin\sigma-j\omega_y\sin\tau\sin
\sigma]\\\Rightarrow F_z(\omega_x,\omega_y)=\dfrac{F_E}{-j\omega_x\cos\tau\sin
\sigma-j\omega_y\sin\tau\sin\sigma}\\Z(x,y)=\Im^{-1}\{F_z(\omega_x,\omega_y)\}
\end{gathered}\]</div><p>The <code>slant</code> and <code>tilt</code> can be manually defined using the function signature:</p><pre><code class="language-none">Z = retrieve_surface(algorithm::Pentland, img::AbstractArray, slant::Real, tilt::Real)</code></pre><p>Note: if <code>slant</code> and <code>tilt</code> are not defined they will be calculated at runtime using <code>estimate_img_properties</code>.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>img</code></strong></p><p>An <code>AbstractArray</code> storing the grayscale value of each pixel within the range [0,1].</p><p><strong><code>slant</code></strong></p><p>A <code>Real</code> that specifies the slant value to be used by the algorithm. The <code>slant</code> should be a value in the range [0,π/2]. If <code>slant</code> is specified to must the <code>tilt</code>.</p><p><strong><code>tilt</code></strong></p><p>A <code>Real</code> that specifies the tilt value to be used by the algorithm. The <code>tilt</code> should be a value in the range [0,2π]. If <code>tilt</code> is specified to must the <code>slant</code>.</p><p><strong>Example</strong></p><p>Compute the heightmap for a synthetic image generated by <code>generate_surface</code>.</p><pre><code class="language-julia">using Images, Makie, ShapeFromShading

#generate synthetic image
img = generate_surface(SynthSphere(), 1, [0.2,0,0.9], radius = 5)

#calculate the heightmap
Z = retrieve_surface(Pentland(), img)

#normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

#display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:2
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><ol><li>A. Pentland, &quot;Shape Information From Shading: A Theory About Human Perception,&quot; [1988 Proceedings] Second International Conference on Computer Vision, Tampa, FL, USA, 1988, pp. 404-413. <a href="https://doi.org/10.1109/ccv.1988.590017 ">doi: 10.1109/CCV.1988.590017</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/pentland.jl#L1-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Photometric-Tuple{AbstractArray,AbstractArray,AbstractArray}" href="#ShapeFromShading.Photometric-Tuple{AbstractArray,AbstractArray,AbstractArray}"><code>ShapeFromShading.Photometric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Z,p,q = retrieve_surface(algorithm::Photometric, img1::AbstractArray, img2::AbstractArray, img3::AbstractArray, illumination_direction1::Vector{T} where T &lt;: Real, illumination_direction2::Vector{T} where T &lt;: Real, illumination_direction3::Vector{T} where T &lt;: Real; integration_scheme::AbstractIntegrationScheme = Horn())</code></pre><p>Attempts to produce the gradients and integrate them to retiereve a height map using three-point photometric stereo.</p><p>This algorithm solves a system of linear equation formed by varying the lighting conditions on an object while holding the viewing angle constant. Note that the ilumination direction id defined negative of most other algorithms and as such inouts may need to be corrected (see example).</p><p><strong>Output</strong></p><p>Returns an M by N array (matching dimensions of original image) of Float <code>Z</code> that represents the reconstructed height at the point and the gradients in M by N arrays of Float <code>p</code> and <code>q</code>.</p><p><strong>Details</strong></p><p>Let ⁠ñ₁, ñ₂ and ñ₃ define the ilumination direction let N be a 3 X 3 matrix whos rows are formed by the row vectors of the illumination direction as per:</p><div>\[N=\begin{bmatrix}&amp;n_{11}&amp;n_{12}&amp;n_{13}\\&amp;n_{21}&amp;n_{22}&amp;n_{23}\\&amp;n_{31}&amp;n_{32}&amp;n_{33}\end{bmatrix}\]</div><p>and I₁, I₂ and I₃ be the intensity values at a point (x,y) and let Ĩ=[I₁,I₂,I₃]′ be the column vector formed by these values.</p><p>The surface normal at the point (x,y) can now be directly calculated using:</p><div>\[ñ=N^{-1}Ĩ\]</div><p>where n is the surface normal.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>img1</code></strong></p><p>An <code>AbstractArray</code> storing the grayscale value of each pixel within the range [0,1].</p><p><strong>`img2</strong></p><p>An <code>AbstractArray</code> storing the grayscale value of each pixel within the range [0,1].</p><p><strong><code>img3</code></strong></p><p>An <code>AbstractArray</code> storing the grayscale value of each pixel within the range [0,1].</p><p><strong><code>illumination_direction1</code></strong></p><p>A <code>Vector{T} where T &lt;: Real</code> that specifies the first illumination vector to be used by the algorithm. The <code>illumination_direction</code> should be a vector of the form [x,y,z] where x,y,z are int he range [0,1].</p><p><strong><code>illumination_direction2</code></strong></p><p>A <code>Vector{T} where T &lt;: Real</code> that specifies the second illumination vector to be used by the algorithm. The <code>illumination_direction</code> should be a vector of the form [x,y,z] where x,y,z are int he range [0,1].</p><p><strong><code>illumination_direction3</code></strong></p><p>A <code>Vector{T} where T &lt;: Real</code> that specifies the third illumination vector to be used by the algorithm. The <code>illumination_direction</code> should be a vector of the form [x,y,z] where x,y,z are int he range [0,1].</p><p><strong><code>integration_scheme</code></strong></p><p>A keywork argument of type <code>AbstractIntegrationScheme</code> which specifies which integration scheme is to be used to reconstruct the surface from the calculated normals.</p><pre><code class="language-julia">using Images, Makie, ShapeFromShading

#generate synthetic images
n₁ = [0,0,1.0]
n₂ = [1.0,0.2,1.0]
n₃ = [0.2,0.9,1.0]
img1, img2, img3 = generate_photometric(n₁, n₂, n₃, 1, shape = SynthSphere(), r = 5)

#calculate the heightmap
Z,p,q = retrieve_surface(Photometric(), img1, img2, img3, -n₁, -n₂, -n₃, integration_scheme = Durou())

#normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

#display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:2
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><ol><li>R. Woodham, &quot;Photometric Method For Determining Surface Orientation From Multiple Images&quot;, Optical Engineering, vol. 19, no. 1, 1980. <a href="https://doi.org/10.1117/12.7972479">doi:10.1117/12.7972479</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/photometric.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Shah-Tuple{AbstractArray}" href="#ShapeFromShading.Shah-Tuple{AbstractArray}"><code>ShapeFromShading.Shah</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Z,p,q = retrieve_surface(algorithm::Shah, img::AbstractArray, iterations::Int=200)</code></pre><p>Attempts to produce a hieghtmap from a grayscale image using Shah&#39;s algorithm.</p><p>Under the assumption that the albedo is constant, and the surface is Lambertian, the algorithm employs discrete approximations of p and q using finite differences in order to linearize the reflectance map in terms of Z by taking the first term of its Taylor series expansion.</p><p><strong>Output</strong></p><p>Returns an M by N array (matching dimensions of original image) of Float <code>Z</code> that represents the reconstructed height at the point and the gradients in M by N arrays of Float &#39;p&#39; and &#39;q&#39;.</p><p><strong>Details</strong></p><p>Given the reflectance map for the surface defined as bellow:</p><div>\[R(x,y)=\dfrac{-i_xp-i_yq+i_z}{\sqrt{1+p^2+q^2}}=\dfrac{\cos\sigma+p\cos\tau\sin
\sigma+q\sin\tau\sin\sigma}{\sqrt{1+p^2+q^2}}\]</div><p>where <span>$i_x=\frac{I(1)}{I(3)}=\frac{\cos\tau\sin\sigma}{\cos\sigma}=\cos\tau \tan\sigma$</span> and <span>$i_y=\frac{I(2)}{I(3)}=\frac{\sin\tau\sin\sigma}{\cos\sigma} =\sin\tau\tan\sigma$</span>.</p><p>and p and q are discretely approximated as:</p><div>\[\begin{gathered}
p=Z(x,y)-Z(x-1,y)\\
q=Z(x,y)-Z(x,y-1)\\
\end{gathered}\]</div><p>Shah linearized the function <span>$f=E-R=0$</span> in terms of <span>$Z$</span> in the vicinity of <span>$Z^{k-1}$</span> by crating a system of linear equations which can be solved iteratively using the Jacobi iterative scheme, simplifying the Taylor series expansion to the first order to get the following:</p><div>\[f(Z(x,y))=0\approx f(Z^{n-1}(x,y))+(Z(x,y)-Z^{n-1}(x,y))\dfrac{df(Z^{n-1}(x,y))}
{dZ(x,y)}\]</div><p>which by letting <span>$Z^n(x,y)=Z(x,y)$</span> gives:</p><div>\[Z^n(x,y=Z^{n-1}(x,y)-\dfrac{f(Z^{n-1}(x,y))}{\dfrac{df(Z^{n-1}(x,y))}{dZ(x,y)}}\]</div><p>where,</p><div>\[\dfrac{df(Z^{n-1}(x,y))}{dZ(x,y)}=\dfrac{(p+q)(pi_x+qi_y+1)}{\sqrt{(1+p^2+q^2)^3}
\sqrt{1+i_x+i_y}}-\dfrac{i_x+i_y}{\sqrt{1+p^2+q^2}\sqrt{1+i_x+i_y}}\]</div><p>which as <span>$Z^0(x,y)=0$</span>, allows the algorithm to iteratively solve for <span>$Z(x,y)$</span>.</p><p>The <code>slant</code> and <code>tilt</code> can be manually defined using the function signature:</p><pre><code class="language-none">Z,p,q = retrieve_surface(algorithm::Shah, img::AbstractArray, slant::Real, tilt::Real, iterations::Int=200)</code></pre><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>img</code></strong></p><p>An <code>AbstractArray</code> storing the grayscale value of each pixel within the range [0,1].</p><p><strong><code>iterations</code></strong></p><p>An <code>Int</code> that specifies the number of iterations the algorithm is to perform. If left unspecified a default value of 200 is used.</p><p><strong><code>slant</code></strong></p><p>A <code>Real</code> that specifies the slant value to be used by the algorithm. The <code>slant</code> should be a value in the range [0,π/2]. If <code>slant</code> is specified to must the <code>tilt</code>.</p><p><strong><code>tilt</code></strong></p><p>A <code>Real</code> that specifies the tilt value to be used by the algorithm. The <code>tilt</code> should be a value in the range [0,2π]. If <code>tilt</code> is specified to must the <code>slant</code>.</p><p><strong>Example</strong></p><p>Compute the heightmap for a synthetic image generated by <code>generate_surface</code>.</p><pre><code class="language-julia">using Images, Makie, ShapeFromShading

#generate synthetic image
img = generate_surface(SynthSphere(), 1, [0.2,0,0.9], radius = 5)

#calculate the heightmap
Z,p,q = retrieve_surface(Shah(), img)

#normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

#display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:2
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><ol><li>T. Ping-Sing and M. Shah, &quot;Shape from shading using linear approximation&quot;, Image and Vision Computing, vol. 12, no. 8, pp. 487-498, 1994. <a href="https://doi.org/10.1016/0262-8856(94)90002-7">doi:10.1016/0262-8856(94)90002-7</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/09fed6af3141d4c93059d77bf047ec0b16731f6d/src/shah.jl#L1-L91">source</a></section></article><h2 id="Benchmarking:-1"><a class="docs-heading-anchor" href="#Benchmarking:-1">Benchmarking:</a><a class="docs-heading-anchor-permalink" href="#Benchmarking:-1" title="Permalink"></a></h2><h2 id="Miscellaneous:-1"><a class="docs-heading-anchor" href="#Miscellaneous:-1">Miscellaneous:</a><a class="docs-heading-anchor-permalink" href="#Miscellaneous:-1" title="Permalink"></a></h2></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 1 December 2019 23:57">Sunday 1 December 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
