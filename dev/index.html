<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Normal-Integration:-1"><span>Normal Integration:</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/betttris13/ShapeFromShading.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ShapeFromShading.jl-1"><a class="docs-heading-anchor" href="#ShapeFromShading.jl-1">ShapeFromShading.jl</a><a class="docs-heading-anchor-permalink" href="#ShapeFromShading.jl-1" title="Permalink"></a></h1><p>The following documents the functionality currently available in ShapeFormShading.jl.</p><h2 id="Normal-Integration:-1"><a class="docs-heading-anchor" href="#Normal-Integration:-1">Normal Integration:</a><a class="docs-heading-anchor-permalink" href="#Normal-Integration:-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Frankot-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Frankot-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Frankot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Frankot()</code></pre><p>Defines the Frankot integrator which contians the Frankot-Chellappa method of integration. The Frankot-Chellappa method is a fast, reliable method for integration surface normals while enforcing integrability using Fourier methods.</p><p><strong>Output</strong></p><p><code>Frankot()</code> returns a Frankot integrator which can then be called to run the Frankot-Chellappa method on a gradient field.</p><p><strong>Details</strong></p><p>Frankot-Chellappa method uses Fourier methods to attempt to solve the Poission equation <span>$\nabla^2z = \partial_up + \partial_vq$</span>. By taking the Fourier transform of both sides we get:</p><div>\[−(\omega^2_u + \omega^2_v)\hat{z}(\omega_u, \omega_v) = \imath \omega_u\hat{p}
(\omega_u, \omega_v) + \imath \omega_v\hat{q}(\omega_u, \omega_v)\]</div><p>By rearanging the above equation we arive at an equation for <span>$\hat{z}$</span>;</p><div>\[\hat{z}(\omega_u, \omega_v) = \frac{\omega_u\hat{p}(\omega_u, \omega_v) +
\omega_v\hat{q}(\omega_u, \omega_v)}{\imath(\omega^2_u + \omega^2_v)}\]</div><p>From which the final surface can be found by taking the inverse Fourier transform of <span>$\hat{z}$</span>.</p><p>Due to the way <span>$(\omega_u, \omega_v)$</span> is defined the algorithm works best when the input dimentions are odd in length. To accomidate this the integrator will pad the edge of the inputs if they are even before running the algorithm. This padding will be removed before returning a value hence output size will be unaffected.</p><p><strong>Parameters</strong></p><p><code>Frankot</code> integrator take no parameters.</p><p><strong>Example</strong></p><p>The following example demontraits the use of the <code>Frankot</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Frankot() integrator
frankot = Frankot()

# Calculate the heightmap from the gradients
Z = frankot(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>R. T. Frankot and R. Chellappa, &quot;A method for enforcing integrability in shape from shading algorithms,&quot; in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 10, no. 4, pp. 439-451, July 1988. <a href="https://doi.org/10.1109/34.3909 ">doi: 10.1109/34.3909</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/ea4bc78668c296b917fa6285deaa1be7c5464431/src/integration.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Path-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Path-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Path()</code></pre><p>Creates a <code>Path()</code> integrator which utilizes the average of two path integrals along varying paths. Each path integral reconstructs the surface with accumilating error along the path, hence averaging two different paths can minimize this error, although the method still suffers if the gradient field is not integrable at some points.</p><p><strong>Output</strong></p><p><code>Path()</code> returns a Path integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>Under the assumption that the surface normals are approximitly integrable everywhere (<span>$\frac{\partial p}{\partial y}\approx\frac{\partial q}{\partial x}$</span>), then surface can be reconstructed using the path integral defined as:</p><div>\[z(x,y)=\oint_c\left(\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}\right)\cdot dl\]</div><p>Which can be broken into two integrals representing the value at each point on the surface as shown below for a path which integrates along the first column then along the row.</p><div>\[z(u,v)=\int_0^v\frac{\partial z}{\partial y}(0,y)dy + \int_0^u\frac{\partial z}{\partial x}(x,v)dx\]</div><p>The second path used in the algorithm is simply the transpose of the first, integrating along the first row then down the column represented mathmatically as:</p><div>\[z(u,v)=\int_0^u\frac{\partial z}{\partial x}(x,0)dx + \int_0^v\frac{\partial z}{\partial y}(u,y)dy\]</div><p>The algorithm can be writen, then  discreatizes as shown below:</p><div>\[\begin{gathered}
z(u,v)=\frac{1}{2}\left(\int_0^v\frac{\partial z}{\partial y}(0,y)dy + \int_0^u\frac{\partial z}{\partial x}(x,v)dx + \int_0^u\frac{\partial z}{\partial x}(x,0)dx + \int_0^v\frac{\partial z}{\partial y}(u,y)dy\right)\\
z(u,v)=\frac{1}{2}\left(\sum_{i=0}^vq(0,i) + \sum_{j=0}^up(j,v) + \sum_{j=0}^up(j,0) + \sum_{i=0}^vq(u,i)\right)\\
z(u,v)=\frac{1}{2}\left(\sum_{i=0}^v(q(0,i) + q(u,i)) + \sum_{j=0}^u(p(j,0) + p(j,v))\right)\\
\end{gathered}\]</div><p>It is important to note as mentioned above if there are non-integrable points in the normal field then artifacts can appear in the reconstruction. This is seen in the example below where the otherwise smooth sphere appears &quot;spiky&quot;. This can be corrected post reconstruction by smoothing but idealy a different integrator should be used.</p><p><strong>Arguments</strong></p><p><code>Path</code> integrator take no parameters.</p><p><strong>Example</strong></p><p>The following example demontraits the use of the <code>Path</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Path() integrator
path = Path()

# Calculate the heightmap from the gradients
Z = path(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>D. Forsyth and J. Ponce, Computer vision: a modern approach. Upper Saddle River, N.J: Prentice Hall, 2003, pp. 84-86.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/ea4bc78668c296b917fa6285deaa1be7c5464431/src/integration.jl#L76-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.SplitPath-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.SplitPath-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.SplitPath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SplitPath()</code></pre><p>Creates a <code>SplitPath()</code> integrator which utilizes the average of two path integrals along varying paths averaging the value at each step. Each path integral reconstructs the surface with accumilating error along the path, hence averaging two different paths at each step reduces the global error at the cost of local error, although the method still suffers if the gradient field is not integrable at some points it does less so the <code>Path()</code> from which it extends.</p><p><strong>Output</strong></p><p><code>SplitPath()</code> returns a SplitPath integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>Under the assumption that the surface normals are approximitly integrable everywhere (<span>$\frac{\partial p}{\partial y}\approx\frac{\partial q}{\partial x}$</span>), then surface can be reconstructed using the path integral defined as:</p><div>\[z(x,y)=\oint_c\left(\frac{\partial z}{\partial x},\frac{\partial z}{\partial y}\right)\cdot dl\]</div><p>By expanding on this principle and the discreate summation from <code>Path()</code> we can arrive at the discreate expresion for the value at each point, assuming all values prior to that point have been calculated, as follows:</p><div>\[z_{u,v} = \frac{1}{2}(z_{u-1,v}+p_{u-1,v}+z_{u,v-1}+q_{u,v-1})\]</div><p>As with other simular methods (see <code>Horn()</code>) care must be taken with regards to boundries which can be calculated, to a constant value <span>$z(0,0)$</span> which is assumed to be the zero point, using:</p><div>\[\begin{gathered}
z_{u,0} = z_{u-1,0}+p_{u-1,0}\\
z_{0,v} = z_{0,v-1}+q_{0,v-1}
\end{gathered}\]</div><p>It is important to note as mentioned above if there are non-integrable points in the normal field then artifacts can appear in the reconstruction. These errors gradully average out but will lead to &quot;streaks&quot; appearing in the reconstruction. This is seen in the example below where the otherwise smooth sphere appears has ripple like structures pointing toward to top right corner. This can be corrected post reconstruction by smoothing but idealy a different integrator should be used. It is also interesting to note the parrallels between this method and the Horn and Brooks methed, with this mehtod being effectivly the forward component of Horn&#39;s method. As such this algorithm provided a usefull middle gorund between direct integration algorithms and iterative algorithms such as the Horn and Brooks mehtod.</p><p><strong>Arguments</strong></p><p><code>SplitPath</code> integrator take no parameters.</p><p><strong>Example</strong></p><p>The following example demontraits the use of the <code>Path</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Path() integrator
splitPath = SplitPath()

# Calculate the heightmap from the gradients
Z = splitPath(p, q)

# Normalize to maximum of 1 (not necessary but makes displaying easier)
Z = Z./maximum(Z)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>[1] D. Forsyth and J. Ponce, Computer vision: a modern approach. Upper Saddle River, N.J: Prentice Hall, 2003, pp. 84-86. [2] B. Horn and M. Brooks, &quot;The variational approach to shape from shading&quot;, Computer Vision, Graphics, and Image Processing, vol. 33, no. 2, pp. 174-208, 1986. <a href="https://doi.org/10.1016/0734-189x(86)90114-3 ">doi: 10.1016/0734-189x(86)90114-3</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/ea4bc78668c296b917fa6285deaa1be7c5464431/src/integration.jl#L173-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Horn-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Horn-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Horn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Horn()</code></pre><p>Impliments the Horn and Brook&#39;s method of integrating surface normals. This algorithm offers an iterative solution to the Poisson equation descriping the surface providing good reconstructions under most conditions.</p><p><strong>Output</strong></p><p><code>Horn()</code> returns a Horn integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>The Horn and Brook&#39;s method attempts to solve the Poisson equation <span>$\nabla^2z = \partial_up + \partial_vq$</span> by the discreatation given below:</p><div>\[z_{u+1,v}+z_{u,v+1}+z_{u-1,v}+z_{u,v-1}-4z_{u,v}=\frac{p_{u+1,v}-p_{u-1,v}}{2}+\frac{q_{u,v+1}-q_{u,v-1}}{2}\]</div><p>Which can be rearanged to give the iterative scheme provided by:</p><div>\[z_{u,v}^{k+1}= \frac{z_{u+1,v}^k + z_{u,v+1}^k + z_{u-1,v}^k + z_{u,v-1}^k}{4} - \frac{p_{u+1,v}-p_{u-1,v}}{8} - \frac{q_{u,v+1}-q_{u,v-1}}{8}\]</div><p>This scheme will always converge to a solution however the rate of convergance may depend upon the initial solution. This implimentation will initilize with a zero solution. Neumann boundry conditions are imposed at the edges where the scheme would otherwise go out of bounds.</p><p><strong>Arguments</strong></p><p>The function parameters are described in more detail below.</p><p><strong><code>Max_iter</code></strong></p><p>An <code>Int</code> which controls the numbe rof iterations the algorithm will run for. the range [0,1].</p><p><strong><code>ϵ</code></strong></p><p>A <code>Real</code> representing the distance between pixels. This will Control how tall the final reconstruction is relative the array grid.</p><p><strong>Example</strong></p><p>The following example demontraits the use of the <code>Path</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Horn() integrator
horn = Horn(ϵ = 0.03, max_iter = 10000)

# Calculate the heightmap from the gradients
Z = horn(p, q)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>B. Horn and M. Brooks, &quot;The variational approach to shape from shading&quot;, Computer Vision, Graphics, and Image Processing, vol. 33, no. 2, pp. 174-208, 1986. <a href="https://doi.org/10.1016/0734-189x(86)90114-3 ">doi: 10.1016/0734-189x(86)90114-3</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/ea4bc78668c296b917fa6285deaa1be7c5464431/src/integration.jl#L262-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShapeFromShading.Durou-Tuple{AbstractArray,AbstractArray}" href="#ShapeFromShading.Durou-Tuple{AbstractArray,AbstractArray}"><code>ShapeFromShading.Durou</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Durou()</code></pre><p>Impliments the Durou and Courteille method of integrating surface normals. This algorithm offers an iterative solution to the Poisson equation descriping the surface extending Horn anf Brook&#39;s method by improving the boundry approximation and providing good reconstructions under most conditions.</p><p><strong>Output</strong></p><p><code>Durou()</code> returns a Horn integrator which can then be called to integrate a gradient field.</p><p><strong>Details</strong></p><p>TheDurou and Courteille&#39;s method attempts to solve the Poisson equation <span>$\nabla^2z = \partial_up + \partial_vq$</span> by the discreatation given below:</p><div>\[z_{u+1,v}+z_{u,v+1}-2z_{u,v}=\frac{p_{u+1,v}+p_{u,v}}{2}+\frac{q_{u,v+1}+q_{u,v}}{2}\]</div><p>Which can be rearanged to give the iterative scheme provided by:</p><div>\[z_{u,v}^{k+1}= \frac{z_{u+1,v}^k + z_{u,v+1}^k}{2} - \frac{p_{u+1,v}+p_{u,v}}{4} - \frac{q_{u,v+1}+q_{u,v}}{4}\]</div><p>This scheme will always converge to a solution however the rate of convergance may depend upon the initial solution. This implimentation will initilize with a zero solution. Natural boundry conditions are imposed at the edges using the condition ``\partial<em>uz-p+\partial</em>v-q=0. Although faster then the Horn and Brook&#39;s method and better at handeling boundries, it can generate a worse solution under some conditions.</p><p><strong>Arguments</strong></p><p>The function parameters are described in more detail below.</p><p><strong><code>Max_iter</code></strong></p><p>An <code>Int</code> which controls the numbe rof iterations the algorithm will run for. the range [0,1].</p><p><strong><code>ϵ</code></strong></p><p>A <code>Real</code> representing the distance between pixels. This will Control how tall the final reconstruction is relative the array grid.</p><p><strong>Example</strong></p><p>The following example demontraits the use of the <code>Path</code> integrator.</p><pre><code class="language-julia">using ShapeFromShading, Makie

# Generate synthetic gradients
p, q = synthetic_gradient(SynthSphere(), radius = 38, img_size = 151)

# Create a Durou() integrator
durou = Durou(ϵ = 0.03, max_iter = 10000)

# Calculate the heightmap from the gradients
Z = durou(p, q)

# Display using Makie (Note: Makie can often take several minutes first time)
r = 0.0:0.1:4
surface(r, r, Z)</code></pre><p><strong>Reference</strong></p><p>[1] Y. Quéau, J. Durou and J. Aujol, &quot;Normal Integration: A Survey&quot;, Journal of Mathematical Imaging and Vision, vol. 60, no. 4, pp. 576-593, 2017. <a href="https://doi.org/10.1007/s10851-017-0773-x ">doi: 10.1007/s10851-017-0773-x</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/betttris13/ShapeFromShading.jl/blob/ea4bc78668c296b917fa6285deaa1be7c5464431/src/integration.jl#L352-L407">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 24 November 2019 23:32">Sunday 24 November 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
